<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Webpack | 随笔小记</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="favicon.ico">
    <meta name="description" content="石宇航的博客">
    
    <link rel="preload" href="/blog/assets/css/0.styles.b2229841.css" as="style"><link rel="preload" href="/blog/assets/js/app.b3969549.js" as="script"><link rel="preload" href="/blog/assets/js/2.03b91b0c.js" as="script"><link rel="preload" href="/blog/assets/js/12.eef3a008.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.c7372d93.js"><link rel="prefetch" href="/blog/assets/js/11.29433f11.js"><link rel="prefetch" href="/blog/assets/js/13.14a9cbc3.js"><link rel="prefetch" href="/blog/assets/js/14.93409171.js"><link rel="prefetch" href="/blog/assets/js/15.074ce28b.js"><link rel="prefetch" href="/blog/assets/js/16.d6ea477a.js"><link rel="prefetch" href="/blog/assets/js/17.2aabea44.js"><link rel="prefetch" href="/blog/assets/js/18.e8ed62c7.js"><link rel="prefetch" href="/blog/assets/js/19.828c4cbb.js"><link rel="prefetch" href="/blog/assets/js/20.aeae618d.js"><link rel="prefetch" href="/blog/assets/js/21.e1db9825.js"><link rel="prefetch" href="/blog/assets/js/22.6fd7192e.js"><link rel="prefetch" href="/blog/assets/js/23.0284509d.js"><link rel="prefetch" href="/blog/assets/js/24.496edd0d.js"><link rel="prefetch" href="/blog/assets/js/25.31059888.js"><link rel="prefetch" href="/blog/assets/js/26.3babb49c.js"><link rel="prefetch" href="/blog/assets/js/27.752e82c1.js"><link rel="prefetch" href="/blog/assets/js/28.c3251fea.js"><link rel="prefetch" href="/blog/assets/js/29.6ab7e8bd.js"><link rel="prefetch" href="/blog/assets/js/3.2a3bc397.js"><link rel="prefetch" href="/blog/assets/js/30.e06fe430.js"><link rel="prefetch" href="/blog/assets/js/31.77de20f0.js"><link rel="prefetch" href="/blog/assets/js/32.9aff7892.js"><link rel="prefetch" href="/blog/assets/js/33.324c57e9.js"><link rel="prefetch" href="/blog/assets/js/34.54e5f43b.js"><link rel="prefetch" href="/blog/assets/js/35.b80cf3d2.js"><link rel="prefetch" href="/blog/assets/js/36.08a4906c.js"><link rel="prefetch" href="/blog/assets/js/4.bdd00efc.js"><link rel="prefetch" href="/blog/assets/js/5.cac11e48.js"><link rel="prefetch" href="/blog/assets/js/6.b2af4ce7.js"><link rel="prefetch" href="/blog/assets/js/7.559262d1.js"><link rel="prefetch" href="/blog/assets/js/8.99e1b260.js"><link rel="prefetch" href="/blog/assets/js/9.f0d3f1f7.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.b2229841.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">随笔小记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/note/" class="nav-link router-link-active">
  Note
</a></div><div class="nav-item"><a href="/blog/article/" class="nav-link">
  Article
</a></div><div class="nav-item"><a href="https://github.com/S-yh/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/note/" class="nav-link router-link-active">
  Note
</a></div><div class="nav-item"><a href="/blog/article/" class="nav-link">
  Article
</a></div><div class="nav-item"><a href="https://github.com/S-yh/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/note/html.html" class="sidebar-link">HTML</a></li><li><a href="/blog/note/css.html" class="sidebar-link">CSS</a></li><li><a href="/blog/note/js.html" class="sidebar-link">JavaScript</a></li><li><a href="/blog/note/vue.html" class="sidebar-link">Vue</a></li><li><a href="/blog/note/react.html" class="sidebar-link">React</a></li><li><a href="/blog/note/node.html" class="sidebar-link">Node</a></li><li><a href="/blog/note/ts.html" class="sidebar-link">TypeScript</a></li><li><a href="/blog/note/webpack.html" aria-current="page" class="active sidebar-link">Webpack</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/note/webpack.html#核心概念" class="sidebar-link">核心概念</a></li><li class="sidebar-sub-header"><a href="/blog/note/webpack.html#配置" class="sidebar-link">配置:</a></li><li class="sidebar-sub-header"><a href="/blog/note/webpack.html#优化" class="sidebar-link">优化</a></li><li class="sidebar-sub-header"><a href="/blog/note/webpack.html#特色" class="sidebar-link">特色</a></li><li class="sidebar-sub-header"><a href="/blog/note/webpack.html#webpack的理解-优点-原理-打包的过程" class="sidebar-link">webpack的理解,优点,原理,打包的过程</a></li><li class="sidebar-sub-header"><a href="/blog/note/webpack.html#实现原理" class="sidebar-link">实现原理</a></li><li class="sidebar-sub-header"><a href="/blog/note/webpack.html#webpack常见loader" class="sidebar-link">webpack常见loader</a></li><li class="sidebar-sub-header"><a href="/blog/note/webpack.html#常见plugin" class="sidebar-link">常见plugin</a></li><li class="sidebar-sub-header"><a href="/blog/note/webpack.html#loader于plugin的区别" class="sidebar-link">loader于plugin的区别</a></li><li class="sidebar-sub-header"><a href="/blog/note/webpack.html#webpack构建流程" class="sidebar-link">webpack构建流程</a></li><li class="sidebar-sub-header"><a href="/blog/note/webpack.html#提高效率的插件" class="sidebar-link">提高效率的插件</a></li><li class="sidebar-sub-header"><a href="/blog/note/webpack.html#热更新原理" class="sidebar-link">热更新原理：</a></li><li class="sidebar-sub-header"><a href="/blog/note/webpack.html#代码分割" class="sidebar-link">代码分割：</a></li><li class="sidebar-sub-header"><a href="/blog/note/webpack.html#bable" class="sidebar-link">Bable</a></li><li class="sidebar-sub-header"><a href="/blog/note/webpack.html#webpack几种hash的不同" class="sidebar-link">webpack几种hash的不同</a></li></ul></li><li><a href="/blog/note/git.html" class="sidebar-link">Git</a></li><li><a href="/blog/note/nginx.html" class="sidebar-link">Nginx</a></li><li><a href="/blog/note/linux.html" class="sidebar-link">Linux</a></li><li><a href="/blog/note/docker.html" class="sidebar-link">Docker</a></li><li><a href="/blog/note/browser.html" class="sidebar-link">浏览器</a></li><li><a href="/blog/note/snippet.html" class="sidebar-link">工具函数/代码片段</a></li><li><a href="/blog/note/algorithm.html" class="sidebar-link">数据结构/算法</a></li><li><a href="/blog/note/performance.html" class="sidebar-link">性能优化</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p><a href="https://juejin.im/post/5e5c65fc6fb9a07cd00d8838" target="_blank" rel="noopener noreferrer">参考1<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <a href="https://juejin.im/post/5e6518946fb9a07c820fbaaf?utm_source=gold_browser_extension" target="_blank" rel="noopener noreferrer">参考2<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h1 id="webpack"><a href="#webpack" class="header-anchor">#</a> Webpack</h1> <p>webpack是一个现代JavaScript应用程序的静态模块打包器, 当webpack处理应用程序时, 会递归构建一个依赖关系图, 其中包含应用程序需要的每一个模块, 然后将这些模块打包成一个或多个bundle.</p> <h2 id="核心概念"><a href="#核心概念" class="header-anchor">#</a> 核心概念</h2> <ul><li>entry: 入口</li> <li>output: 输出</li> <li>loader: 模块转换器, 用于把模块原内容按照需求转换成新内容,执行顺序从右向左</li> <li>plugin: 扩展插件, 在webpack构建流程中的特定时机注入扩展逻辑来改变构建结果</li></ul> <h2 id="配置"><a href="#配置" class="header-anchor">#</a> 配置:</h2> <ul><li>在webpack.config.js进行配置, module.exports ={entry: '', output: '', mode: 'development'}</li> <li>loader需要配置在module.rules中, rules输一个数组,  格式: {test: /.js$/, use: '', include: //, exclude:/node_modules/}
<ul><li>use字段几种写法
<ul><li>字符串, use: 'babel-loader'</li> <li>数组, use: ['style-loader', 'css-loader']</li> <li>对象: use : {loader: 'babel-loader', options:{presets: [&quot;@babel/preset-env&quot;]}}</li></ul></li></ul></li> <li>mode配置项, 告知webpack使用相应模式的内置优化,支持两个配置, development, production,
<ul><li>development:  将 process.env.NODE_ENV 的值设置为 development，启用 NamedChunksPlugin 和 NamedModulesPlugin</li> <li>production:   将 process.env.NODE_ENV 的值设置为 production，启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 UglifyJsPlugi</li></ul></li> <li>devtool可以帮助我们将编译后的代码映射回原始源代码, 生产环境可以使用none或者source-map</li> <li>处理css等样式文件
<ul><li>借助loader,  css需要 style-loader, css-loader, postcss-loader,  less,scss需要 less-loader, sass-loader</li> <li>style-loader 动态创建style标签. 将css插入到head中.</li> <li>css-loader负责处理@import等语句</li> <li>postcss-loader和autoprefixer自动生成浏览器兼容性前缀</li> <li>less-loader,scss-loader负责解析.less .scss文件, 将其转化为css</li></ul></li> <li>图片/字体等静态文件处理
<ul><li>借助url-loader或者file-loader来处理本地的资源文件</li> <li>url-loader可以指定文件大小的限制, 小于限制转换为base64, 超过的 拷贝到dist目录</li> <li>资源转换为base64可以减少网络请求次数, 但是base64数据较大, 如果过多会导致加载变慢</li></ul></li> <li>出口配置
<ul><li>output: {path: path.resolve(__dirname, 'dist'), filename: 'bundle.[hash:6].js', publicPath: '/'}</li></ul></li> <li>打包前清空dist目录
<ul><li>借助clean-webpack-plugin插件</li> <li>dist中某个目录不清除, 参数: cleanOnceBeforeBuildPatterns</li></ul></li> <li>静态资源拷贝
<ul><li>有时候需要使用本地的js,css等文件, 但是不需要webpack编译,可以通过CopyWebpackPlugin拷贝到编译目录下</li></ul></li> <li>全局变量
<ul><li>ProvidePlugin作用就是不需要import或require就可以在项目中到处使用</li> <li>ProvidePlugin是webpack的内置插件</li> <li>例: new Webpack.ProvidePlugin({ React: 'react' , Vue: ['vue/dist/vue.esm.js', 'default']})</li> <li>注: 通过export default到处的 需要加 'default',  module.exports 不要写 'default'</li></ul></li> <li>按需加载
<ul><li>需要@babel/plugin-syntax-dynamic-import插件支持, 在 @babel/preset-env 内置</li> <li>使用 import('./handle') 可以实现按需加载</li></ul></li> <li>热更新
<ul><li>devServer : { hot: true }</li> <li>插件:  webpack.HotModuleReplacementPlugin</li> <li>避免整个页面刷新,  入口文件中加入 if( module &amp;&amp; module.hot ) { module.hot.accept() }</li></ul></li> <li>多页应用打包
<ul><li>HtmlWebpackPlugin 提供了一个 chunks 的参数，可以接受一个数组，配置此参数仅会将数组中指定的js引入到html文件中，此外，如果你需要引入多个JS文件，仅有少数不想引入，还可以指定 excludeChunks 参数，它接受一个数组。<br> <img src="/blog/assets/img/mul-page.85481c00.png" alt="mul-pages"></li></ul></li> <li>resolve 配置
<ul><li>modules  配置webpack去哪些目录下寻找第三方模块, 默认只会去node_modules寻找</li> <li>alias: 别名</li> <li>extensions:  适配多端的项目中, extensions: ['web.js',  '.js'] 在缺省文件后缀时, 会自动带上extensions中配置的后缀, 按顺序左 → 右</li> <li>enforceExtension: true  导入语句不能缺省文件后缀</li> <li>mainFields</li></ul></li> <li>区分不同环境
<ul><li>创建多个配置文件: webpack.base.js, webpack.dev.js, webpack.prod.js</li> <li>webpack-merge 合并配置文件</li></ul></li> <li>webpack.DefinePlugin: 定义全局环境变量</li> <li>解决跨域
<ul><li>配置代理</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>devServer<span class="token operator">:</span> <span class="token punctuation">{</span>
    proxy<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token string">'/api'</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            target<span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>
            pathRewrite<span class="token operator">:</span> <span class="token punctuation">{</span>
                <span class="token string">'/api'</span><span class="token operator">:</span> <span class="token string">''</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>模拟数据
<ul><li>mocker-api</li></ul></li></ul> <h2 id="优化"><a href="#优化" class="header-anchor">#</a> 优化</h2> <ul><li>通过exclude, include排除或指定转译的文件
<ul><li>exclude优先级高于include,  使用绝对路径数组,</li></ul></li> <li>在一些性能开销大的loader之前添加cache-loader可以将结果缓存在磁盘中.</li> <li>通过HappyPack能够让Webpack做到这点.
<ul><li>把任务分解给多个子进程去并发的执行, 子进程处理完后再把结果发送给主进程</li></ul></li></ul> <h2 id="特色"><a href="#特色" class="header-anchor">#</a> 特色</h2> <ul><li>code splitting(可以自动完成) (根据代码的分割对文件进行分块)</li> <li>loader 可以处理各种类型的静态文件, 并且支持串联操作,</li> <li>webpack是一commonJS的形式来书写脚本的, 但对AMD/CMD的支持也很全面, 方便旧项目进行代码迁移,</li> <li>webpack机油requireJS和browserify的功能,</li> <li>对js, css, 图片等资源文件都支持打包,</li> <li>串联式模块加载器以及插件机制, 让其具有更好的灵活性和扩展性</li> <li>独立的配置文件</li> <li>将代码切割成不同chunk, 实现按需加载</li> <li>webpack使用异步IO并具有多级缓存, 是的webpack很快且增量编译更快</li></ul> <h2 id="webpack的理解-优点-原理-打包的过程"><a href="#webpack的理解-优点-原理-打包的过程" class="header-anchor">#</a> webpack的理解,优点,原理,打包的过程</h2> <ul><li>优点:
<ul><li>依赖管理, 方便引用第三方模块, 让模块更容易复用, 避免全局注入导致的冲突.避免重复加载或加载不需要的模块</li> <li>合并代码: 把各个分散的模块集中打包成大文件, 减少HTTP的请求连接数, 配合 UglifyJS 可以减少, 优化代码体积</li></ul></li> <li>原理:
<ul><li>一切皆为模块, 由于webpack并不支持除 .js意外的文件, 从而需要使用loader转换成wenpack支持的模块, Plugin用于扩展webpack的功能, 在webpack构建生命周期的过程在合适的时机做了合适的事情</li></ul></li> <li>过程:
<ul><li>解析配置参数, 合并shell传入和webpack.config.js文件的配置信息, 输出最终的配置信息</li> <li>注册配置中的插件, 好让插件监听webpack构建生命周期中的事件节点, 做出对应的反应</li> <li>解析配置文件中的entry入口文件, 并找出每个文件依赖的文件, 递归下去</li> <li>在递归每个文件的过程中. 根据文件类型和配置文件中loader找出相对应的loader对文件进行转换</li> <li>递归结束之后得到每个文件最终的结果, 根据entry配置生成代码chunk</li> <li>输出所有chunk到文件系统</li></ul></li></ul> <h2 id="实现原理"><a href="#实现原理" class="header-anchor">#</a> 实现原理</h2> <ul><li>分析依赖: 从一个入口文件开始分析, 当我们把一个入口的文件路径传入, webpack就会通过这个文件路径读取文件信息, 然后把读取到的信息转成AST, 就是把一个js文件里面的内容存到某种数据结构里, 里面包括各种信息, 其中就有当前模块依赖了哪些模块, 通过传文件路径能返回文件信息的函数叫 createAsset</li> <li>createAsset返回什么 ?  包括模块ID, 文件路径, 依赖数组, code, 循环调用, 得到所有依赖, 想得到全部依赖信息需要调用createGraph这个函数. 它会进行广度遍历</li> <li>我们现在已经能拿到每个模块之前的依赖关系，我们再通过调用bundle函数，其实bundle函数就是返回我们构造的字符串，拿到字符串，我们把字符串导出成bundle.js</li></ul> <h2 id="webpack常见loader"><a href="#webpack常见loader" class="header-anchor">#</a> webpack常见loader</h2> <ul><li>raw-loader：加载文件原始内容</li> <li>file-loader： 把文件输出到一个文件夹，通过相对URL去引用输出的文件（处理图片和字体）</li> <li>url-loader： 也file-loader类似，不同的是在小于阈值时，返回文件base64形式编码</li> <li>source-map-loader： 加载额外的sourceMap文件，方便断电调试</li> <li>image-loader： 加载并且压缩图片文件</li> <li>json-loader： 加载json文件</li> <li>babel-loader： 将es6转换成es5</li> <li>ts-loader： 将typescript转为JavaScript</li> <li>awesome-typescript-loader： 功能同ts-loader，性能更优</li> <li>sass-loader： 将scss、sass代码转换成css</li> <li>css-loader：加载css，支持模块化，压缩，文件导入等特性</li> <li>style-loader：把css代码注入到JavaScript，通过dom操作去加载css</li> <li>postcss-loader： 扩展css语法，自动补齐前缀</li> <li>eslint-loader：通过eslint检查JavaScript代码</li> <li>tslint-loader： 通过tslint检查代码</li> <li>mocha-loader加载Mocha测试用例的代码</li> <li>coverjs-loader：计算测试覆盖率</li> <li>vue-loader：加载vue单文件组件</li> <li>i18n-loader：国际化</li></ul> <h2 id="常见plugin"><a href="#常见plugin" class="header-anchor">#</a> 常见plugin</h2> <ul><li>define-plugin： 定义环境变量</li> <li>ignore-plugin：忽略部分文件</li> <li>html-webpack-plugin：简化HTML文件创建</li> <li>web-webpack-plugin：输出Html，比html-wepack-plugin好用</li> <li>terser-webpack-plugin：支持es6压缩</li> <li>webpack-parallel-uglify-plugin：多进程执行代码压缩，提升构建速度</li> <li>mini-css-extract-plugin：分离样式，css提取为独立文件，支持按需加载</li> <li>serviceworker-webpack-plugin：为网页应用增加离线缓存功能</li> <li>clean-webpack-plugin：目录清理</li> <li>speed-measure-webpack-plugin：可以看到每个loader和plugin执行耗时</li> <li>webpack-bundle-analyzer：可视化webpack输出文件的体积</li> <li>happypack：优化代码打包速度，多进程</li></ul> <h2 id="loader于plugin的区别"><a href="#loader于plugin的区别" class="header-anchor">#</a> loader于plugin的区别</h2> <ul><li>loader本质上是一个函数，在函数中对接受到的内容进行转换， 返回转换后的结果，loader是翻译官，转化为webpack可识别的JavaScript，对其他资源预处理</li> <li>plugin是插件，插件可以扩展webpack的功能，在webpack的运行周期中会广播出许多事件，plugin监听这些事件，在合适的时机通过webpack提供API改变输出结果。</li></ul> <h2 id="webpack构建流程"><a href="#webpack构建流程" class="header-anchor">#</a> webpack构建流程</h2> <ul><li>初始化参数--&gt;开始编译--&gt;确定入口--&gt;编译模块--&gt;完成模块编译--&gt;输出资源--&gt;输出完成</li> <li>webpack会在特定的时间点广播出特定的事件,提供给plugin监听</li></ul> <h2 id="提高效率的插件"><a href="#提高效率的插件" class="header-anchor">#</a> 提高效率的插件</h2> <ul><li>webpack-dashboard:友好的展示相关打包信息</li> <li>webpack-merge： 提供公共配置，减少重复配置</li> <li>hotModuleReplacementPlugin： 模块热替换</li></ul> <h2 id="热更新原理"><a href="#热更新原理" class="header-anchor">#</a> 热更新原理：</h2> <ul><li>HMR的核心就是客户端从服务端拉去更新后的文件（chunk diff），实际上WDS与浏览器之间维护了一个Websocker，当本地资源发生变化时，WDS会向浏览器推送更新，并带上构建时的hash，让客户端与上一次资源进行对比，对比出差异之后会发送Ajax请求获取更改内容，这样客户端就可以再借助这些信息继续向WDS发起jsonp请求获取该chunk的增量更新</li></ul> <h2 id="代码分割"><a href="#代码分割" class="header-anchor">#</a> 代码分割：</h2> <ul><li>在源代码直接上线和打包成唯一脚本之间的一种状态，“用可接受的服务器心梗压力增加来换取更好的用户体验”</li> <li>源代码直接上线：http请求多，性能开销大</li> <li>唯一脚本，服务器压力小，页面空白期长，用户体验不好</li></ul> <h2 id="bable"><a href="#bable" class="header-anchor">#</a> Bable</h2> <ul><li>babel 是一个JavaScript编译器, 用于将ECMAScript 2015+版本的代码转换为向后兼容的JavaScript语法, 以便能够运行在当前版本和旧版本的浏览器或其他环境中
<ul><li>语法转换</li> <li>通过Polyfill的方式在目标环境中添加缺失的特性</li> <li>JS源码转换</li></ul></li> <li>原理: 核心是AST,  首先将源码转成抽象语法树, 然后对语法树进行处理生成新的语法树, 最后将新语法树生成新的js代码, 整个编译过程分为3个阶段,  parsing(解析) --&gt; transforming(转换)--&gt;generating(生成), 都是围绕着AST去做文章,</li> <li>使用:
<ul><li>@babel/cli
<ul><li>@babel/cli 是babel提供的内建命令行工具</li></ul></li> <li>@babel/core</li></ul></li> <li>配置: 配置文件的四种形式
<ul><li>babel.config.js   在根目录创建</li> <li>.babelrc</li> <li>.babelrc.js    module.exports = { presets: [], plugins: {} }</li> <li>package.json中添加 &quot;babel&quot; 属性</li></ul></li> <li>插件: 插件是用来定义如何转换代码的, 在babel的配置项中填写需要使用的插件名称. babel在编译的时候就会去加载node_modules中的npm包, 然后编译插件对应的语法
<ul><li>插件执行顺序:  插件在预设前运行, 插件的执行顺序是从左往右执行的,</li> <li>插件传参: 参数是由插件名称和参数对象组成的一个数组</li></ul></li> <li>预设: 是一堆插件的组合, 从而达到某种转译的能力, 比如react中使用到的@babel/preset-react是由 @babel/plugin-syntax-jsx, @babel/plugin-transform-react-jsx, @babel/plugin-transform-react-display-name 组成
<ul><li>预设的执行顺序是 从右往左</li></ul></li></ul> <h2 id="webpack几种hash的不同"><a href="#webpack几种hash的不同" class="header-anchor">#</a> webpack几种hash的不同</h2> <ul><li>hash是跟整个项目的构建相关, 只要项目里有文件更改, 整个项目构建的hash值都会更改, 并且全部文件都共用相同的hash值(粒度整个项目)</li> <li>chunkhash是根据不同的入口进行依赖文件解析, 构建对应的chunk, 生成对应的hash值, 只有被修改的chunk在重新构建之后才会生成新的hash值, 不会影响其他的chunk(粒度entry的每个入口文件)</li> <li>contenthash是跟每个生成文件相关, 每个文件都有一个唯一的hash值, 当要构建的文件内容发生改变时, 就会生成新的hash值, 且该文件的改变并不会影响和他同一个模块下的其他文件(粒度每个文件的内容)</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/note/ts.html" class="prev">
        TypeScript
      </a></span> <span class="next"><a href="/blog/note/git.html">
        Git
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.b3969549.js" defer></script><script src="/blog/assets/js/2.03b91b0c.js" defer></script><script src="/blog/assets/js/12.eef3a008.js" defer></script>
  </body>
</html>
