(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{368:function(e,t,v){"use strict";v.r(t);var r=v(43),_=Object(r.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"vue实现原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue实现原理"}},[e._v("#")]),e._v(" vue实现原理:")]),e._v(" "),v("p",[e._v("从入口开始 import Vue from 'vue'"),v("br"),e._v("\n------------------------初始化-------------------------------首次构建")]),e._v(" "),v("ul",[v("li",[e._v("src/platforms/web/entry-runtime-with-compile.js :")]),e._v(" "),v("li",[e._v("引入 Vue from src/platforms/web/runtime/index,")]),e._v(" "),v("li",[e._v("缓存原型链上的$mount函数,")]),e._v(" "),v("li",[e._v("并重写$mount(通过compileToFunctions将template编译为render函数),")]),e._v(" "),v("li",[e._v("并调用缓存的mount函数")]),e._v(" "),v("li",[e._v("src/platforms/web/runtime/index.js:")]),e._v(" "),v("li",[e._v("引入 Vue from  src/core/index.js")]),e._v(" "),v("li",[e._v("对Vue对象进行扩展, 包含定义$mount, 安装一个平台相关的 "),v("strong",[e._v("patch")]),e._v(" 等")]),e._v(" "),v("li",[e._v("src/core/index.js:")]),e._v(" "),v("li",[e._v("引入Vue from src/core/instance/index.js")]),e._v(" "),v("li",[e._v("并调用initGlobalApi, 初始化全局 API")]),e._v(" "),v("li",[e._v("src/core/instance/index.js:")]),e._v(" "),v("li",[e._v("Vue构造函数, new Vue时, 执行构造函数内_init 函数")]),e._v(" "),v("li",[e._v("src/core/instance/init.js:")]),e._v(" "),v("li",[e._v("初始化主要是, 合并配置, 初始化生命周期, 事件中心, 渲染, data,props,computed, watcher等,")]),e._v(" "),v("li",[e._v("最后检测如果有 el 属性, 则调用 vm.$mount方法进行实例挂载")]),e._v(" "),v("li",[e._v("实例挂载:")]),e._v(" "),v("li",[e._v("通过$mount方法去挂载vm,  src/platform/web/entry-runtime-with-compiler.js 定义的是带有compiler版本的$mount, 并缓存原型上的$mount,")]),e._v(" "),v("li",[e._v("判断如果不存在render函数, 则调用compileToFunctions将template编译返回render函数,")]),e._v(" "),v("li",[e._v("最后调用缓存的$mount函数")]),e._v(" "),v("li",[e._v("定义在 src/platform/web/runtime/index.js在原型中的$mount方法:")]),e._v(" "),v("li",[e._v("调用 mountComponent方法.")]),e._v(" "),v("li",[e._v("定义在 src/core/instance/lifecycle.js中的mountComponent方法:")]),e._v(" "),v("li",[e._v("核心是 实例化一个渲染Watcher, 传入updateComponent作为回调,")]),e._v(" "),v("li",[e._v("updateComponent函数中会调用vm._render生成虚拟Node,")]),e._v(" "),v("li",[e._v("将生成的VNode传入 vm._update 更新dom,")]),e._v(" "),v("li",[e._v("Watcher在这里起到两个作用, 一个是初始化的时候执行回调, 另一个是当vm实例监测的数据发生变化时执行回调")]),e._v(" "),v("li",[e._v("定义在src/core/instance/render.js中的 _render方法:")]),e._v(" "),v("li",[e._v("主要是调用 在new Vue时传入的render方法,或编译template生成的render方法,")]),e._v(" "),v("li",[e._v("并将vm.$createElement传入为参数,")]),e._v(" "),v("li",[e._v("vm.$createElement是在 initRender时创建的, 内部调用了 createElement方法,")]),e._v(" "),v("li",[e._v("render方法返回的是VNode(虚拟dom)")]),e._v(" "),v("li",[e._v("定义在src/core/vdom/create-element.js 的createElement方法: 主要是生成vnode,")]),e._v(" "),v("li",[e._v("实际是对_createElement方法的封装,真正创建VNode的函数,")]),e._v(" "),v("li",[e._v("5个参数, context,上下文, tag: 标签, data, vnode数据, children vnode子节点, normalizationType: 子节点规范的类型.")]),e._v(" "),v("li",[e._v("_createElement函数主要工作是: 规范化children为VNode类型的数组, 创建VNode 如果是内置节点, new VNode(), 如果是组件, createComponent创建组件类型VNode,")]),e._v(" "),v("li",[e._v("定义在src/core/instance/lifecycle.js的_update")]),e._v(" "),v("li",[e._v("作用是把VNode渲染成真实的DOM,")]),e._v(" "),v("li",[e._v("调用时机有两个, 一个是首次渲染,一个是数据更新的时候,")]),e._v(" "),v("li",[e._v("_update内部核心是调用vm.__patch__方法, 这个方法在浏览器端渲染时, 指向patch方法,")]),e._v(" "),v("li",[e._v("定义在src/platform/web/runtime/patch.js中的patch方法,")]),e._v(" "),v("li",[e._v("是createPatchFunction方法的返回值, 包含 nodeOps和 module两个参数")]),e._v(" "),v("li",[e._v("createPatchFuncton是一个柯里化函数,")]),e._v(" "),v("li",[e._v("patch方法本身接受4个参数, oldNode, 旧Vnode, vnode, 新vnode hydrating, 是否服务端渲染, removeOnly是给transition-group用的,")]),e._v(" "),v("li",[e._v("经过一些复杂的逻辑后调用createElm函数")]),e._v(" "),v("li",[e._v("createElm")]),e._v(" "),v("li",[e._v("作用是通过虚拟节点创建真实的DOM并插入到它的父节点中,")]),e._v(" "),v("li",[e._v("createComponent是尝试创建子组件,")]),e._v(" "),v("li",[e._v("createChildren方法创建子元素, 实际上是遍历子虚拟节点, 递归调用createElm,")]),e._v(" "),v("li",[e._v("深度优先遍历算法,")]),e._v(" "),v("li",[e._v("至此真实dom渲染完成.")]),e._v(" "),v("li",[e._v("整个过程 new Vue --\x3e init --\x3e $mount --\x3e compile --\x3e render --\x3e Vnode --\x3e patch --\x3e DOM")])]),e._v(" "),v("p",[e._v("组件化")]),e._v(" "),v("ul",[v("li",[e._v("定义在src/core/vdom/create-component.js中的createComponent主要三个关键步骤,")]),e._v(" "),v("li",[e._v("构造子类构造函数(baseCtor.extend(Ctor)), baseCtor实际上是Vue, Vue.extend(定义在src/core/global-api/extend.js)通过原型继承的方式把纯对象转换为一个继承于Vue的构造器Sub并返回, 然后扩展一些属性, 并初始化, 并缓存, 避免多次执行")]),e._v(" "),v("li",[e._v("安装组件钩子函数, {init, prepatch, insert, destroy}合并到data.hook中, 在VNode执行patch的过程中执行相关的钩子函数,")]),e._v(" "),v("li",[e._v("实例化VNode, 返回VNode")]),e._v(" "),v("li",[e._v("patch中createElm创建组件的VNode,")]),e._v(" "),v("li",[e._v("createComponent, 首先判断是组件VNode,会执行创建组件时合并的钩子函数, init钩子函数会 基于子类构造函数 vnode.componentOptions.Ctor() 创建一个实例.这个时机就是子组件的实例化,会执行this._init(), 并调用$mount函数,....")]),e._v(" "),v("li",[e._v("接下来遍历VNode递归调用createElm, 如果遇到子VNode是组件的VNode,重复执行, 通过一个递归的方式完整的构建了整个组件树,")]),e._v(" "),v("li",[e._v("在完成组件的整个patch过程后, 最后执行insert()完成dom插入, 如果组件patch过程又创建了子组件, 插入顺序是先子后父")])]),e._v(" "),v("p",[e._v("合并配置")]),e._v(" "),v("ul",[v("li",[e._v("在vm._init(option)方法中会执行 mergeOption")]),e._v(" "),v("li",[e._v("外部调用: 实际上是把 resolveConstructorOption(vm.constructor)的返回值(Vue.options)和options合并")])]),e._v(" "),v("p",[e._v("生命周期\n*")]),e._v(" "),v("p",[e._v("组件注册\n*")]),e._v(" "),v("p",[e._v("异步组件\n*")]),e._v(" "),v("h2",{attrs:{id:"响应式原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#响应式原理"}},[e._v("#")]),e._v(" 响应式原理")]),e._v(" "),v("p",[e._v("------------------------响应式原理-------------------------------\n响应式原理Object.defineProperty")]),e._v(" "),v("ul",[v("li",[e._v("Object.defineProperty(obj, prop, descriptor)会直接在一个对象上定义一个新属性或修改一个对象的现有属性, 并返回这个属性")]),e._v(" "),v("li",[e._v("initState: 在Vue初始化阶段, _init执行的时候, 会执行initState(vm)方法, 定义在 src/core/instance/state.js, initState方法主要是对props, methods, data,computed和watcher等属性做了初始化操作,")]),e._v(" "),v("li",[e._v("initProps: 遍历定义的props配置,")]),e._v(" "),v("li",[e._v("调用defineReactive方法把每个prop对应的值变成响应式, 可以通过vm._props.xx 访问到定义props中对应的属性,")]),e._v(" "),v("li",[e._v("通过proxy把vm._props.xxx 的访问代理到vm.xxx 上")]),e._v(" "),v("li",[e._v("initData: 遍历")]),e._v(" "),v("li",[e._v("通过proxy把每一个值vm._data.xxx代理到vm.xxx,")]),e._v(" "),v("li",[e._v("调用observe方法观测整个data的变化, 把data也变成响应式")]),e._v(" "),v("li",[e._v("proxy: 代理的作用是把props和data上的属性代理到vm实例上,")]),e._v(" "),v("li",[e._v("通过Object.defineProperty把target[source][key]的读写变成了对target[key]的读写,")]),e._v(" "),v("li",[e._v("observe: 监测数据的变化, 定义在src/core/observe/index.js")]),e._v(" "),v("li",[e._v("作用是给非VNode的对象类型数据添加一个Observer, 如果已经添加直接返回, ,否则去实例化一个Observer对象实例,")]),e._v(" "),v("li",[e._v("Observer: 给对象添加getter和setter 用来依赖收集和派发更新")]),e._v(" "),v("li",[e._v("实例化Dep, 执行def函数将自身实例添加到数据对象 value的__ob__属性上,")]),e._v(" "),v("li",[e._v("判断value类型, 数组调用observeArray, 纯对象调用walk方法,")]),e._v(" "),v("li",[e._v("observeArray是 遍历数组再次调用observe方法")]),e._v(" "),v("li",[e._v("walk方法是遍历对象的key调用defineReactive方法")]),e._v(" "),v("li",[e._v("defineReactive就是定义一个响应式对象, 给对象动态设置getter和setter, 定义在src/core/observer/index.js")]),e._v(" "),v("li",[e._v("初始化Dep实例, 然后拿到obj的属性描述符, 对子属性递归调用observe, 保证子属性也能变成响应式的对象.")]),e._v(" "),v("li",[e._v("依赖收集: 响应式对象getter相关的逻辑就是依赖收集")]),e._v(" "),v("li",[e._v("定义在src/core.observer/dep.js 的 Dep类, 是整个getter依赖收集的核心, Dep有一个静态属性target, 这是全局唯一Watcher, Dep实际上就是对Watcher的一种管理, Dep脱离Watcher单独存在没有意义,")]),e._v(" "),v("li",[e._v("过程分析; 当我们在mountComponent函数中, 实例化一个渲染watcher时, 首先进入Watcher的构造函数逻辑, 会执行他的this.get()方法, 方法里会执行pushTarget函数,实际是把Dep.target指向当前的渲染watcher,并压栈,接着执行 vm._update(vm._render(),hydrating), 会先执行vm._render(),这个方法会生成VNode, 并且这个过程会对vm上的数据访问, 这个时候就触发了数据对象的getter, 那么每一个对象值的getter都持有一个dep, 在触发getter的时候会调用dep.depend(), 把当前watcher订阅到这个数据持有的dep的subs中, 为了在后续数据变化时通知subs做准备,在vm._render()过程中, 会触发所有数据的getter,这样实际完成了一个依赖收集的过程, 之后再栈中恢复上一个状态, 并清空依赖")]),e._v(" "),v("li",[e._v("派发更新: 收集依赖的目的就是为了当修改数据的时候")]),e._v(" "),v("li",[e._v("defineReactive中 setter的逻辑有两个关键的点. 如果shallow为false,会对新设置的值为响应式对象, 另一个是dep.notify(), 通知所有的订阅者.")]),e._v(" "),v("li",[e._v("过程分析: 当组件中的响应数据做了修改, 就会触发setter的逻辑, 最后调用dep.notify()方法, 这个方法主要是遍历所有subs, 也就是watcher实例数组, 然后调用每个watcher的update方法, update方法里会对不同状态的watcher执行不同的逻辑, 最后执行queueWatcher(this)的逻辑, 这里引入队列的概念, 使得它不会每次数据改变都触发watcher的回调, 而是把这些watcher先添加到一个队列里, 然后在nextTick后执行flushSchedulerQueue, flushSchedulerQueue函数主要先对队列排序, 然后遍历执行watcher.run(), run函数实际上就是执行this.getAndInvoke方法, 并传入watcher的回调函数, getAndInvoke主要逻辑是, 先通过this.get(), 得到他当前的值, 然后根据一些条件执行watcher回调函数, 对于watcher而言, 在执行this.get()求值时, 会执行getter方法, 也就是vm._update(vm._render(), hydrating), 所以这就是当我们去修改组件相关的响应式数据时, 会触发组件重新渲染的原因,接着就会重新执行patch过程.")]),e._v(" "),v("li",[e._v("vm.$set是如何实现响应式的")]),e._v(" "),v("li",[e._v("内部调用defineReactive, 并手动触发依赖通知 dep.notify()")])]),e._v(" "),v("h2",{attrs:{id:"spa-单页面的理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#spa-单页面的理解"}},[e._v("#")]),e._v(" SPA 单页面的理解")]),e._v(" "),v("p",[e._v("SPA (single-page application) 仅在Web页面初始化时加载相应的Html,JavaScript和Css,一旦加载完成,SPA不会因为用户的操作而进行重新加载或跳转;取而代之的是利用路由机制实现Html内容的变换,UI与用户的交互,避免页面的重新加载.")]),e._v(" "),v("ul",[v("li",[e._v("优点:")]),e._v(" "),v("li",[e._v("用户体验好, 快")]),e._v(" "),v("li",[e._v("服务器压力小")]),e._v(" "),v("li",[e._v("前后端职责分离,架构清晰")]),e._v(" "),v("li",[e._v("缺点")]),e._v(" "),v("li",[e._v("初次加载耗时多")]),e._v(" "),v("li",[e._v("不能使用浏览器前进后退功能")]),e._v(" "),v("li",[e._v("SEO难度大,天然弱势")])]),e._v(" "),v("h2",{attrs:{id:"v-if-与-v-show"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#v-if-与-v-show"}},[e._v("#")]),e._v(" v-if 与 v-show")]),e._v(" "),v("p",[e._v('v-if是真正的条件渲染,直到第一次条件为真,才会开始渲染. v-show总是会被渲染,简单的基于css "display" 属性进行切换 v-if用于不频繁切换条件的场景,v-show用于频繁切换条件的场景')]),e._v(" "),v("h2",{attrs:{id:"class动态绑定"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#class动态绑定"}},[e._v("#")]),e._v(" class动态绑定")]),e._v(" "),v("ul",[v("li",[e._v("对象语法 "),v("code",[e._v("<div v-bind:class=\"{active: isActive, 'text-danger': hasError}\"></div>")])]),e._v(" "),v("li",[e._v("数组语法 "),v("code",[e._v("<div v-bind:class=\"[isActive: ? activeClass: '', errorClass]\"></div>")])])]),e._v(" "),v("h2",{attrs:{id:"怎么理解vue单向数据流"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#怎么理解vue单向数据流"}},[e._v("#")]),e._v(" 怎么理解Vue单向数据流")]),e._v(" "),v("p",[e._v("Vue 父子组件 prop之间形成了一个单向下行绑定, 父级prop的更新会向下流动到子组件中, 但是不能逆向流动, 这样可以防止子组件意外改变父组件的状态, 导致数据流向难以理解. 每次父组件发生更新时, 子组件的prop都会刷新微最新的值, 所以子组件内部不应改变prop,只能通过$emit派发一个自定义事件,通知父组件进行修改.")]),e._v(" "),v("h2",{attrs:{id:"computed-和-watch"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#computed-和-watch"}},[e._v("#")]),e._v(" Computed 和 watch")]),e._v(" "),v("ul",[v("li",[e._v("computed 计算属性, 依赖其他属性值, 且只有它依赖的值发生改变, 才会重新计算")]),e._v(" "),v("li",[e._v("watch 观察, 类似于监听, 每当数据变化时都会进行回调.")])]),e._v(" "),v("p",[e._v("运用场景")]),e._v(" "),v("ul",[v("li",[e._v("当需要数值计算, 且依赖于其他属性时, 使用computed, 可避免重复计算.")]),e._v(" "),v("li",[e._v("当需要在数据变化时, 执行异步操作或开销较大的操作时, 使用watch. 使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。")])]),e._v(" "),v("h2",{attrs:{id:"vue能检测到数组变化吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue能检测到数组变化吗"}},[e._v("#")]),e._v(" Vue能检测到数组变化吗")]),e._v(" "),v("p",[e._v("Vue不能检测到数组的变动, 可使用Vue.$set(array, indexOfArray, newValue) 或 Array.prototype.splice")]),e._v(" "),v("h2",{attrs:{id:"vue生命周期vue"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue生命周期vue"}},[e._v("#")]),e._v(" Vue生命周期Vue")]),e._v(" "),v("p",[e._v("开始创建 -> 初始化数据 -> 编译模板 -> 挂载DOM -> 渲染、更新 -> 渲染、卸载\n|beforeCreate| 组件实例被创建之初，组件的属性生效之前|\n|created| 组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用|\n|beforeMount| 在挂载开始之前被调用：相关的 render 函数首次被调用|\n|mounted| el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子|\n|beforeUpdate| 组件数据更新之前调用，发生在虚拟 DOM 打补丁之前|\n|update| 组件数据更新之后|\n|activited| keep-alive 专属，组件被激活时调用|\n|deadctivated| keep-alive 专属，组件被销毁时调用|\n|beforeDestory| 组件销毁前调用|\n|destoryed| 组件销毁后调用")]),e._v(" "),v("h2",{attrs:{id:"vue-router"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-router"}},[e._v("#")]),e._v(" Vue-Router")]),e._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),v("p",[e._v("vue-router: 这里的理由就是SPA的路径管理器, 路由模块的本质就是建立起url和页面之间的映射关系, SPA的核心之一就是--\x3e更新视图")])]),e._v(" "),v("ul",[v("li",[e._v("hash模式:location.hash 单页应用. 每次hash值的变化, 触发hashchange事件, 通过这个事件可以知道hash值发生了哪些变化, 监听来实现页面的操作")]),e._v(" "),v("li",[e._v("history模式: 通过 pushState, replaceState可以改变url地址且不发送请求, 同时还有popstate, 通过监听事件实现路由, 但是因为没有#号, 所以当用户刷新页面时,浏览器还是会发送请求,为了避免这些情况. 需要服务器的支持, 把所有路由重定向到根页面")]),e._v(" "),v("li",[e._v("Vue.use执行install 方法安装vue-router插件")]),e._v(" "),v("li",[e._v("混入 beforeCreate, destroyed")]),e._v(" "),v("li",[e._v("注册全局组件 RouterView, RouterLink")]),e._v(" "),v("li",[e._v("劫持Vue.prototype.$router, Vue.prototype.$route, 返回 this._routerRoot._router,this._routerRoot._route")]),e._v(" "),v("li",[e._v("初始化router")]),e._v(" "),v("li",[e._v("构造函数接收路由配置选项给this.options")]),e._v(" "),v("li",[e._v("根据mode的不同实现不同的History类, 返回的实例赋值给this.history")]),e._v(" "),v("li",[e._v("实例化Vue实例")]),e._v(" "),v("li",[e._v("实例化router后, 在new Vue时把router作为配置属性传入, 那么在beforeCreate钩子中会执行 this._router.init(this), 传入了vue实例,存储到this.apps, 并根据this.history的不同执行不同逻辑,主要通过history.transitionTo方法")]),e._v(" "),v("li",[e._v("history.transitionTo定义在History基类中，先通过match方法传入目标路由获取到描述目标路由的route对象，再调用confirmTransition函数执行跳转。而在VueRouter类中，可以看到match方法调用的实际上是matcher属性的match方法，而matcher是由createMatcher函数生成的.")])]),e._v(" "),v("h2",{attrs:{id:"vue异步执行dom更新的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue异步执行dom更新的"}},[e._v("#")]),e._v(" Vue异步执行DOM更新的")]),e._v(" "),v("ul",[v("li",[e._v("观察到数据变化, Vue开启一个队列, 并缓冲在同一事件循环中发生的所有数据改变")]),e._v(" "),v("li",[e._v("如果同一个watcher被多次触发, 只会被推入到队列中一次, 这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作上非常必要")]),e._v(" "),v("li",[e._v("然后, 在下一个事件循环tick中, Vue刷新队列并执行实际工作, Vue内部尝试对异步队列使用原生的Promise,then和MessageChannel, 如果执行环境不支持, 会采用setTimeout(fn,0)代替")])]),e._v(" "),v("h2",{attrs:{id:"响应式原理-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#响应式原理-2"}},[e._v("#")]),e._v(" 响应式原理")]),e._v(" "),v("ul",[v("li",[e._v("如何追踪变化")]),e._v(" "),v("li",[e._v("当你把一个普通的JavaScript对象传给Vue实例的data选项, Vue将遍历次对象所有的属性, 并使用Object.defineProperty把这些属性全部转为getter/setter")]),e._v(" "),v("li",[e._v("Object.defineProperty 是ES5中一个无法shim的特性,所有不支持IE8及更低浏览器")]),e._v(" "),v("li",[e._v("这些getter/setter对用户来说不可见, 但是在内部他们让Vue追踪依赖, 在属性被访问和修改时通知变化,")]),e._v(" "),v("li",[e._v("每个组件实例都有对应的watcher实例对象, 他会在组件渲染的过程中把属性记录为依赖, 之后当依赖项的setter被调用时. 会通知watcher重新计算, 从而致使它关联的组件得以更新")]),e._v(" "),v("li",[e._v("观察者订阅了可观察对象, 当可观察对象发布事件, 则就直接调度观察者的行为, 所以这里观察者和可观察对象其实就产生了一个依赖关系.")])]),e._v(" "),v("h2",{attrs:{id:"virtual-dom算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#virtual-dom算法"}},[e._v("#")]),e._v(" virtual DOM算法")]),e._v(" "),v("ul",[v("li",[e._v("用JavaScript对象结构表示DOM树的结构, 然后用这个树构建真正的DOM树, 查到文档中")]),e._v(" "),v("li",[e._v("当状态变更的时候, 重新构造一颗新的对象树, 然后用这个新和旧的树进行比较, 记录两棵树的差异,")]),e._v(" "),v("li",[e._v("把记录的差异应用到所构建的真正的DOM树上, 视图就更新了")])]),e._v(" "),v("p",[e._v("比较两颗DOM树的差异是virtual DOM算法最核心的部分, 这也是所谓的Virtual DOM的diff算法, 两个数的完全的diff算法是一个时间复杂度为O(n^3)的问题, 但是在前端当中, 你很少会跨越层级的移动DOM元素, 所以Virtual DOM diff只会对同一个层级的元素进行对比, 这样算法复杂度, 可以达到O(n) . 在实际的代码中. 会对新旧两颗树进行一个深度优先的遍历, 这样每个节点有会有一个唯一的标记, 在深度优先遍历的时候. 每遍历一个节点就把该节点和新的树进行对比, 如果有差异的话就记录到一个对象里面, virtual DOM diff 算法主要是实现上面步骤的三个函数, element, diff, patch")]),e._v(" "),v("h2",{attrs:{id:"v-model的原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#v-model的原理"}},[e._v("#")]),e._v(" v-model的原理")]),e._v(" "),v("ul",[v("li",[e._v("v-model在内部为不同的输入元素使用不同的属性, 并抛出不同的事件,")]),e._v(" "),v("li",[e._v("text和textarea元素使用value, input事件")]),e._v(" "),v("li",[e._v("CheckBox和radio使用checked change事件")]),e._v(" "),v("li",[e._v("select字段将value作为prop并将change作为事件")])]),e._v(" "),v("h2",{attrs:{id:"vuex"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vuex"}},[e._v("#")]),e._v(" vuex:")]),e._v(" "),v("p",[e._v("一个专为vue.js 应用程序开发的状态管理模式, 每一个Vuex应用的核心就是store, store基本上是一个容器, 他包含着你的应用大部分的状态,")]),e._v(" "),v("ul",[v("li",[e._v("vuex的状态存储是响应式的 ,  当vue组件从store中读取状态时, 若store中的状态发生变化, 那么响应的组件也会响应的得到高效更新")]),e._v(" "),v("li",[e._v("改变store中的状态的唯一途径就是现实的提交mutation, 这样我们可以方便的跟踪每一个状态的变化")])]),e._v(" "),v("h2",{attrs:{id:"双向绑定的实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#双向绑定的实现"}},[e._v("#")]),e._v(" 双向绑定的实现")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("实现一个监听器Observer, 对数据对象进行遍历, 包括子属性对象的属性, 利用Object.defineProperty, 对属性都加上setter和getter,这样的话, 给这个对象的某个值复制, 就会触发setter, 那么就能监听到了数据变化.")])]),e._v(" "),v("li",[v("p",[e._v("实现一个解析器Compile, 解析Vue模板指令, 将模板中的变量都替换成数据, 然后初始化渲染页面视图, 并将每个指令对应的节点绑定更新函数, 添加监听数据的订阅者, 一旦数据有变动, 收到通知, 调用更新函数进行数据更新")])]),e._v(" "),v("li",[v("p",[e._v("实现一个订阅者Watcher, watcher订阅者是Observer和compile之间通信的桥梁, 主要的任务是订阅Observer中的属性变化的消息,当收到属性值变化的消息是, 触发解析器, Compile中对应的更新函数")])]),e._v(" "),v("li",[v("p",[e._v("实现一个订阅器Dep, 订阅器采用发布订阅设计模式, 用来收集订阅者watcher, 对监听器Observer和订阅者, watcher进行统一管理")])]),e._v(" "),v("li",[v("p",[e._v("响应式原理:")])])]),e._v(" "),v("p",[e._v("Vue在初始化阶段会给定义在data中的每一项添加一个Observer, Observer主要是实例化Dep,用来依赖收集,然后遍历数据对象的key调用defineReactive方法,defineReactive就是定义一个响应式对象,通过Object.defineProperty给对象动态设置setter和gettergetter的逻辑主要就是依赖收集, 依赖收集的核心就是Dep类, Dep有一个静态属性target是全局唯一Watcher, Dep实际就是对Watcher的管理,依赖收集的过程主要是在mountComponent(挂载阶段)中, 实例化一个watcher, 并将Dep.target指向当前watcher,并压栈,接着执行vm._update(vm._render()),也就是生成虚拟dom(render)以及把虚拟dom渲染成真实dom(patch),这个过程会访问vue实例(vm)上的数据,触发getter每一个对象都有一个dep实例, 触发getter时会调用dep.depend(), 把当前watcher订阅到这个dep的subs中. 为了在后续数据变化时通知subs.setter的逻辑主要是派发更新, 过程主要是 当响应数据被修改就会触发setter,会调用dep.notify(),这个方法主要是遍历所有subs,也就是watcher实例数组.中间会将watcher添加到队列, 在nextTick后调用watcher.run(),主要工作是得到当前的值(this.get()),然后执行watcher回调函数,在获取当前值的时候会触发getter, 也就会触发render,patch,使组件重新渲染.")]),e._v(" "),v("h2",{attrs:{id:"vue项目优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue项目优化"}},[e._v("#")]),e._v(" Vue项目优化")]),e._v(" "),v("ol",[v("li",[e._v("代码层面的优化")])]),e._v(" "),v("ul",[v("li",[e._v("v-if 和 v-show 区分使用场景")]),e._v(" "),v("li",[e._v("computed 和 watch 区分使用场景")]),e._v(" "),v("li",[e._v("v-for 遍历必须为 item 添加 key，且避免同时使用 v-if")]),e._v(" "),v("li",[e._v("长列表性能优化")]),e._v(" "),v("li",[e._v("事件的销毁")]),e._v(" "),v("li",[e._v("图片资源懒加载")]),e._v(" "),v("li",[e._v("路由懒加载")]),e._v(" "),v("li",[e._v("第三方插件的按需引入")]),e._v(" "),v("li",[e._v("优化无限列表性能")]),e._v(" "),v("li",[e._v("服务端渲染 SSR or 预渲染")])]),e._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[e._v("Webpack 层面的优化")])]),e._v(" "),v("ul",[v("li",[e._v("Webpack 对图片进行压缩")]),e._v(" "),v("li",[e._v("减少 ES6 转为 ES5 的冗余代码")]),e._v(" "),v("li",[e._v("提取公共代码")]),e._v(" "),v("li",[e._v("模板预编译")]),e._v(" "),v("li",[e._v("提取组件的 CSS")]),e._v(" "),v("li",[e._v("优化 SourceMap")]),e._v(" "),v("li",[e._v("构建结果输出分析")]),e._v(" "),v("li",[e._v("Vue 项目的编译优化")])]),e._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[e._v("基础的 Web 技术的优化")])]),e._v(" "),v("ul",[v("li",[e._v("开启gzip压缩")]),e._v(" "),v("li",[e._v("浏览器缓存,")]),e._v(" "),v("li",[e._v("cdn")])]),e._v(" "),v("h2",{attrs:{id:"vue底层实现原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue底层实现原理"}},[e._v("#")]),e._v(" vue底层实现原理")]),e._v(" "),v("ul",[v("li",[e._v("vue.js 是采用数据劫持结合发布者-订阅者模式的方式, 通过Object.definePorperty()来劫持各个属性的setter和getter,在数据变动的时候发布消息给订阅者, 触发相应的监听回调.")]),e._v(" "),v("li",[e._v("实现这种双向绑定需要三大模块")]),e._v(" "),v("li",[e._v("Observer(数据监听器): Observer的核心是通过Object.defineProperty()来监听数据的变动, 这个函数内部可以定义setter和getter, 当数据变化时, 触发setter, 这时Observer通知订阅者, Watcher")]),e._v(" "),v("li",[e._v("Watcher(订阅者): Watcher订阅者作为Observer和Compile之间的桥梁, 主要做的事是")]),e._v(" "),v("li",[e._v("在自身实例化时往属性订阅器(dep)里面添加自己")]),e._v(" "),v("li",[e._v("自身有一个update方法")]),e._v(" "),v("li",[e._v("待属性变动dep.notice()通知时, 能调用自身的update方法. 并触发Compile绑定的回调函数")]),e._v(" "),v("li",[e._v("Compile(指令解析器): Compile主要做的事情就是解析模板指令, 将模板中变量替换成数据, 然后初始化渲染页面视图, 并将每个指令对应的节点绑定更新函数, 添加监听数据的订阅者, 一旦数据变动, 收到通知, 更新视图")])]),e._v(" "),v("h2",{attrs:{id:"vue组件间通信方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue组件间通信方式"}},[e._v("#")]),e._v(" Vue组件间通信方式")]),e._v(" "),v("ul",[v("li",[e._v("props/ $emit")]),e._v(" "),v("li",[e._v("$emit/ $on(事件总线): 利用空的Vue实例")]),e._v(" "),v("li",[e._v("vuex")]),e._v(" "),v("li",[e._v("$attrs/ $listeners")]),e._v(" "),v("li",[e._v('$attrs: 包含了父作用域中不被prop所识别(且获取)的特性绑定(class和style除外). 当一个组件没有声明任何prop时, 包含所有父作用域的绑定, 可以通过v-bind="$attrs"传入子组件')]),e._v(" "),v("li",[e._v('$listeners: 包含了父作用域中的v-on事件监听器(不含 .native修饰器的), 他可以通过v-on="$listeners"传入内部组件')]),e._v(" "),v("li",[e._v("provide/inject : 允许一个祖先组件想其子孙后代注入一个依赖, 祖先组件中通过provide来提供变量, 然后在子孙组件通过inject注入变量, provide/inject主要解决跨级组件间的通信问题, 主要使用场景是子组件获取上级组件的状态, 跨级组件间建立了一种主动提供与依赖注入的关系")]),e._v(" "),v("li",[e._v("$parent/ $children与 ref")]),e._v(" "),v("li",[e._v("ref: 如果用在普通DOM元素上, 引用指向的就是DOM元素, 如果用在子组件上, 引用就是指向组件实例")]),e._v(" "),v("li",[e._v("$parent/ $children 访问父/子实例")])]),e._v(" "),v("h2",{attrs:{id:"vue-3-0proxy与2-x-defineproperty"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-3-0proxy与2-x-defineproperty"}},[e._v("#")]),e._v(" vue 3.0proxy与2.x defineProperty")]),e._v(" "),v("ul",[v("li",[e._v("defineProperty:")]),e._v(" "),v("li",[e._v("无法监听数组的变化, 数组没有setter和getter(可使用vm.$set(array, index, value),  vm.array.splice(index, num, value)实现监听)")]),e._v(" "),v("li",[e._v("只能劫持对象的属性(使用vm.$set(object, key, value)实现监听)")]),e._v(" "),v("li",[e._v("proxy:")]),e._v(" "),v("li",[e._v("直接监听对象, 而不是属性")]),e._v(" "),v("li",[e._v("可以监听数组的变化")]),e._v(" "),v("li",[e._v("proxy有多大13种拦截办法,")]),e._v(" "),v("li",[e._v("返回一个新对象")]),e._v(" "),v("li",[e._v("兼容问题大")])]),e._v(" "),v("h2",{attrs:{id:"vue事件机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue事件机制"}},[e._v("#")]),e._v(" vue事件机制")]),e._v(" "),v("ul",[v("li",[e._v("初始化事件,")]),e._v(" "),v("li",[e._v("Vue初始化时, initEvents方法在vm上创建一个_events对象, 用来存放事件, 就下来调用initState方法, 接下来Vue将html解析成AST 将事件绑定到target元素上")]),e._v(" "),v("li",[e._v("$on, 用来监听一个自定义事件, 可用$emit触发")]),e._v(" "),v("li",[e._v("$once监听只能触发一次的事件, 触发后会自动移除")]),e._v(" "),v("li",[e._v("$off用来移除自定义事件")]),e._v(" "),v("li",[e._v("$emit 用来触发自定义事件")])]),e._v(" "),v("h2",{attrs:{id:"vue-diff算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-diff算法"}},[e._v("#")]),e._v(" vue diff算法")]),e._v(" "),v("p",[e._v("patch方法中")]),e._v(" "),v("ul",[v("li",[e._v("patch函数有两个参数oldNode，Vnode")]),e._v(" "),v("li",[e._v("首先判断sameNode（oldnode，vnode）：主要根据tag，key等")]),e._v(" "),v("li",[e._v("如果判断不值得比较，直接（vnode）替换oldNode")]),e._v(" "),v("li",[e._v("如果判断值得比较，执行patchNode（oldNode，Vnode），这个函数主要工作")]),e._v(" "),v("li",[e._v("找到真实dom")]),e._v(" "),v("li",[e._v("判断oldNode和vnode是否指向同一个对象，是则return")]),e._v(" "),v("li",[e._v("如果他们都有文本节点且不相等，将el文本节点设置为Vnode文本节点")]),e._v(" "),v("li",[e._v("如果oldVnode有子节点而Vnode没有，则删除el的子节点")]),e._v(" "),v("li",[e._v("如果oldNode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el")]),e._v(" "),v("li",[e._v("如果两者都有子节点，则执行updateChildren函数比较子节点")]),e._v(" "),v("li",[e._v("updateChildren函数")]),e._v(" "),v("li",[e._v("将Vnode的子节点和oldNode的子节点提取出来")]),e._v(" "),v("li",[e._v("oldChild和vchild各有两个头尾的变量startIdx和endIdx，它们的两个变量相互比较，一共有四种方式，如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较过程中，变量会往中间靠，一旦startIdx大于endIdx表明oldChild和vchild至少有一个遍历结束，就会结束比较，如果oldChild遍历先结束，则把vnode剩余的直接插入到相应的index位置，如果vchild先结束，删除oldchild剩余的真实dom")])]),e._v(" "),v("h2",{attrs:{id:"vue自定义指令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue自定义指令"}},[e._v("#")]),e._v(" vue自定义指令")]),e._v(" "),v("ul",[v("li",[e._v("全局指令:")])]),e._v(" "),v("div",{staticClass:"language-js extra-class"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code",[e._v("Vue"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[e._v("directive")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),v("span",{pre:!0,attrs:{class:"token string"}},[e._v("'focus'")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),v("span",{pre:!0,attrs:{class:"token function-variable function"}},[e._v("inserted")]),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),v("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("el")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("...")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),v("ul",[v("li",[e._v("局部指令:")])]),e._v(" "),v("div",{staticClass:"language-js extra-class"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code",[e._v("directives"),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    focus"),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n        "),v("span",{pre:!0,attrs:{class:"token function-variable function"}},[e._v("inserted")]),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),v("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("el")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("...")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n    "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),v("ul",[v("li",[v("p",[e._v("钩子函数(可选):")]),e._v(" "),v("ul",[v("li",[e._v("bind: 只调用一次. 指令第一次绑定到元素时调用. 在这里可以进行一次性的初始化设置")]),e._v(" "),v("li",[e._v("inserted: 被绑定元素插入父节点时调用. (仅保证父节点存在, 不一定被插入文档)")]),e._v(" "),v("li",[e._v("update:所在组件的vnode更新时调用. 但是可能发生在其子vnode更新之前, 指令的值可能发生了改变. 也可能没有, 但是你可以通过比较更新前后的值来忽略不必要的模板更新")]),e._v(" "),v("li",[e._v("componentUpdated: 指令所在组件的VNode及其子vnode全部更新后调用")]),e._v(" "),v("li",[e._v("unbind:只调用一次. 指令与元素解绑时调用")])])]),e._v(" "),v("li",[v("p",[e._v("钩子函数参数")]),e._v(" "),v("ul",[v("li",[e._v("el: 指令所绑定的元素,可以用来直接操作dom")]),e._v(" "),v("li",[e._v("bingding: 一个对象, 包含以下属性\n"),v("ul",[v("li",[e._v("name: 指令名")]),e._v(" "),v("li",[e._v("value: 指定的绑定值")]),e._v(" "),v("li",[e._v("oldValue: 指令绑定的前一个值")]),e._v(" "),v("li",[e._v("expression: 字符串形式的指令表达式")]),e._v(" "),v("li",[e._v("arg: 传给指令的参数")]),e._v(" "),v("li",[e._v("modifiers: 一个包含修饰符的对象")])])]),e._v(" "),v("li",[e._v("vnode: vue编译生成的虚拟节点")]),e._v(" "),v("li",[e._v("oldVnode: 上一个虚拟节点")])])])]),e._v(" "),v("h2",{attrs:{id:"vue-ssr"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-ssr"}},[e._v("#")]),e._v(" Vue SSR")]),e._v(" "),v("blockquote",[v("p",[e._v("优势")])]),e._v(" "),v("ul",[v("li",[e._v("更好的SEO, 由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面")]),e._v(" "),v("li",[e._v("更快的内容到达时间,更好的用户体验.")])]),e._v(" "),v("blockquote",[v("p",[e._v("限制")])]),e._v(" "),v("ul",[v("li",[e._v("开发条件限制: 只能使用某些生命周期钩子函数.")]),e._v(" "),v("li",[e._v("服务器渲染应用程序,需要处于nodejs运行环境")]),e._v(" "),v("li",[e._v("更多的服务器端负载.")])])])}),[],!1,null,null,null);t.default=_.exports}}]);