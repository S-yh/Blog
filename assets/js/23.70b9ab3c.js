(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{398:function(t,s,a){"use strict";a.r(s);var e=a(42),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"vue-js-3-0"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-js-3-0"}},[t._v("#")]),t._v(" Vue.js 3.0")]),t._v(" "),a("h2",{attrs:{id:"新增特性及优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#新增特性及优化"}},[t._v("#")]),t._v(" 新增特性及优化")]),t._v(" "),a("ul",[a("li",[t._v("代码管理: 通过monorepo管理")]),t._v(" "),a("li",[t._v("类型检查: 通过TypeScript重构代码")]),t._v(" "),a("li",[t._v("性能优化:\n"),a("ul",[a("li",[t._v("移除一些features")]),t._v(" "),a("li",[t._v("引入tree-shaking: 只打包引入的模块. 减少vue.js打包体积")])])]),t._v(" "),a("li",[t._v("数据劫持优化: 通过Proxy API劫持\n"),a("ul",[a("li",[t._v("proxy不能监听到内部深层次的对象变化, vue3是在getter中取递归响应式")])])]),t._v(" "),a("li",[t._v("编译优化:\n"),a("ul",[a("li",[t._v("patch过程优化: 相比于vue2的基于组件的变化, vue3 利用block tree 将模板基于动态节点.借助block tree 将vnode更新性能由模板整体大小提升为与动态内容的数量相关")]),t._v(" "),a("li",[t._v("slot的编译优化")]),t._v(" "),a("li",[t._v("事件监听器的缓存优化")]),t._v(" "),a("li",[t._v("重写diff算法")])])]),t._v(" "),a("li",[t._v("语法优化:\n"),a("ul",[a("li",[t._v("composition API, 优化逻辑复用,更好的类型支持")])])])]),t._v(" "),a("h2",{attrs:{id:"组件渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件渲染"}},[t._v("#")]),t._v(" 组件渲染")]),t._v(" "),a("ul",[a("li",[t._v("创建vnode -> 渲染vnode -> 生成dom")])]),t._v(" "),a("h3",{attrs:{id:"应用程序初始化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#应用程序初始化"}},[t._v("#")]),t._v(" 应用程序初始化")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("createApp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'vue'")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" App "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./app'")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" app "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("createApp")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("App"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\napp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("mount")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'#app'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n")])])]),a("h3",{attrs:{id:"核心渲染流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#核心渲染流程"}},[t._v("#")]),t._v(" 核心渲染流程")]),t._v(" "),a("ul",[a("li",[t._v("创建vnode和渲染vnode\n"),a("ul",[a("li",[t._v("vnode: 本质上是用来描述DOM 的JavaScript对象, 他在Vue.js中可以描述不同类型的节点, 比如普通元素节点, 组件节点等")]),t._v(" "),a("li",[t._v("优势:\n"),a("ol",[a("li",[t._v("抽象: 可以把渲染过程抽象化,从而使得组件的抽象能力也得到提升")]),t._v(" "),a("li",[t._v("跨平台: 因为patch vnode的过程不同平台可以有自己的实现. 基于vnode再做服务端渲染. weex平台, 小程序平台渲染")])])]),t._v(" "),a("li",[t._v("初始渲染两件事情:\n"),a("ol",[a("li",[t._v("渲染组件生成subTree")]),t._v(" "),a("li",[t._v("把subTree挂载到container中")])])])])])])])}),[],!1,null,null,null);s.default=n.exports}}]);