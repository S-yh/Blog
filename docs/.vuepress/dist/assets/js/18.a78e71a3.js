(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{339:function(v,e,_){"use strict";_.r(e);var t=_(33),l=Object(t.a)({},(function(){var v=this,e=v.$createElement,_=v._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"性能优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[v._v("#")]),v._v(" 性能优化")]),v._v(" "),_("p",[_("a",{attrs:{href:"https://juejin.im/post/5c46cbaee51d453f45612a2c",target:"_blank",rel:"noopener noreferrer"}},[v._v("参考1"),_("OutboundLink")],1),v._v(" "),_("a",{attrs:{href:"https://juejin.im/post/5c471eaff265da616d547c8c",target:"_blank",rel:"noopener noreferrer"}},[v._v("参考2"),_("OutboundLink")],1),v._v(" "),_("a",{attrs:{href:"https://juejin.im/post/5c473cdae51d45518d4701ff",target:"_blank",rel:"noopener noreferrer"}},[v._v("参考3"),_("OutboundLink")],1)]),v._v(" "),_("h2",{attrs:{id:"ssr-服务端渲染"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ssr-服务端渲染"}},[v._v("#")]),v._v(" SSR 服务端渲染")]),v._v(" "),_("ul",[_("li",[v._v("对于"),_("code",[v._v("SSR")]),v._v("来说,服务器返回的是结构相对完整的"),_("code",[v._v("HTML")]),v._v("文件,浏览器可以直接解析并渲染出页面.")]),v._v(" "),_("li",[v._v("而对于CSR来说, 浏览器拿到的只是包含JavaScript代码的HTML文件, 浏览器渲染出页面之前, 需要动态创建"),_("code",[v._v("HTML")]),v._v("标签.")]),v._v(" "),_("li",[v._v("也就是说, "),_("code",[v._v("SSR")]),v._v("可以让浏览器边下载JavaScript文件边渲染HTML页面. 用户可以在"),_("code",[v._v("下载React,构建虚拟dom,绑定事件")]),v._v("完成之前就看到页面,"),_("code",[v._v("CSR")]),v._v("需要等到这些操作完成之后才可以看到页面.")]),v._v(" "),_("li",[v._v("使用SSR渲染的另一大优势: 不容易常出现白屏.")]),v._v(" "),_("li",[v._v("对SEO优化, 容易被搜索引擎抓取到")])]),v._v(" "),_("p",[v._v("缺点:")]),v._v(" "),_("ul",[_("li",[v._v("虽然浏览器可以更早的渲染出HTML页面, 但是在"),_("code",[v._v("React")]),v._v("没有执行之前, 页面不可以交互.")])]),v._v(" "),_("h2",{attrs:{id:"减少请求数量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#减少请求数量"}},[v._v("#")]),v._v(" 减少请求数量")]),v._v(" "),_("ul",[_("li",[v._v("合并\n"),_("ul",[_("li",[v._v("如果不进行合并,有以下隐患:\n"),_("ol",[_("li",[v._v("文件与文件之间有插入的上行请求, 增加了N-1个网络延迟")]),v._v(" "),_("li",[v._v("受丢包问题影响更严重")]),v._v(" "),_("li",[v._v("经过代理服务器时可能会被断开")])])]),v._v(" "),_("li",[v._v("合并的问题\n"),_("ol",[_("li",[v._v("首屏渲染问题")]),v._v(" "),_("li",[v._v("缓存失效问题")])])]),v._v(" "),_("li",[v._v("建议\n"),_("ol",[_("li",[v._v("公共库合并")]),v._v(" "),_("li",[v._v("不同页面单独合并")])])])])]),v._v(" "),_("li",[v._v("图片处理\n"),_("ul",[_("li",[v._v("雪碧图"),_("br"),v._v("\ncss雪碧图把图片整合到一张单独的图片中, 减少HTTP请求数量,但是图片比较大, 随着字体图标,svg的流行, 渐渐退出历史的舞台")]),v._v(" "),_("li",[v._v("base64"),_("br"),v._v("\n将图片内容以base64格式内嵌到HTML中, 可以减少HTTP请求数量, 但是由于base4编码用8位字符表示信息中的6个位,所以编码后大小大约比原始值扩大了33%")]),v._v(" "),_("li",[v._v("使用字体图标代替图片")])])]),v._v(" "),_("li",[v._v("减少重定向\n"),_("ul",[_("li",[v._v("尽量避免重定向, 当页面发生了重定向, 就会延迟整个HTML文档的传输, 在HTML文档到达之前, 页面中不会呈现任何东西, 也没有任何组件会被下载, 降低了用户体验")]),v._v(" "),_("li",[v._v("如果一定要使用重定向, 如http重定向到https, 要使用301永久重定向, 而不是302临时重定向, 如果使用302, 则每一次访问http,都会被重定向到https的页面, 而永久重定向,访问一次后,每次访问http,会直接返回https的页面")])])]),v._v(" "),_("li",[v._v("使用缓存\n"),_("ul",[_("li",[v._v("使用cache-control或expires这类强缓存时, 缓存不过期的情况下, 不向服务器发送请求, 强缓存过期时, 会使用last-modified或etag这类协商缓存, 向服务器发送请求, 如果资源没有变化, 则服务器返回304响应, 浏览器继续从本地缓存加载资源, 如果资源更新了. 则服务器将更新后的资源发送到浏览器. 并返回200响应")])])]),v._v(" "),_("li",[v._v("不使用css @import\n"),_("ul",[_("li",[v._v("css的@import会造成额外的请求")])])]),v._v(" "),_("li",[v._v("避免使用空的src和href\n"),_("ul",[_("li",[_("code",[v._v("a标签")]),v._v("设置空的href,会重定向到当前的页面地址")]),v._v(" "),_("li",[v._v("form设置空的method,会提交表单到当前的页面地址")])])])]),v._v(" "),_("h2",{attrs:{id:"减小资源大小"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#减小资源大小"}},[v._v("#")]),v._v(" 减小资源大小")]),v._v(" "),_("ul",[_("li",[v._v("压缩\n"),_("ul",[_("li",[v._v("HTML压缩"),_("br"),v._v("\nHTML代码压缩就是压缩在文本文件中有意义的, 但是在html中不显示的字符,包括空格, 制表符, 换行符等")]),v._v(" "),_("li",[v._v("CSS压缩"),_("br"),v._v("\nCSS压缩包括无效代码删除与css语义合并")]),v._v(" "),_("li",[v._v("js压缩与混乱"),_("br"),v._v("\njs压缩与混乱包括无效字符及注释的删除, 代码语义的缩减和优化, 降低代码可读性, 实现代码保护")]),v._v(" "),_("li",[v._v("图片压缩"),_("br"),v._v("\n针对真实图片情况, 舍弃一些相对无关紧要的色彩信息")])])]),v._v(" "),_("li",[v._v("webp\n"),_("ul",[_("li",[v._v("在安卓下可以使用webp格式的图片, 它具有更优的图像数据压缩算法, 能带来更小的图片体积, 同等画面质量下, 体积比jpg, png少了25%以上, 而且同时具备了无损和有损的压缩模式, alpha透明,以及动画的特性")])])]),v._v(" "),_("li",[v._v("开启gzip\n"),_("ul",[_("li",[v._v("http协议上的gzip编码是一种用来改进web应用程序性能的技术, 大流量的web站点常常使用gzip压缩技术来让用户感受更快的速度, 这一般是指ww服务器中安装的一个功能, 当访问服务器的网站时, 服务器中的这个功能将网页内容压缩后传输到浏览器中, 一般对纯文本内容可压缩到原大小的40%.")])])])]),v._v(" "),_("h2",{attrs:{id:"优化网络连接"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优化网络连接"}},[v._v("#")]),v._v(" 优化网络连接")]),v._v(" "),_("ul",[_("li",[v._v("使用CDN"),_("br"),v._v("\nCDN全称是Content Delivery Network, 内容分发网络, 它能够实时地根据网络流量和各节点的连接, 负载状况以及到用户的距离和响应时间等综合信息将用户请求重新导向离用户最近的服务节点上, 其目的是使用户可就近取得所需的内容, 解决Internet网络拥挤的状态, 提高用户访问网站的响应速度.")]),v._v(" "),_("li",[v._v("使用DNS预解析"),_("br"),v._v("\n当浏览器访问一个域名的时候, 需要解析一次域名, 获得对应的IP地址, 在解析过程中, 按照"),_("code",[v._v("浏览器缓存 --\x3e 系统缓存 --\x3e 路由器缓存 --\x3e ISP(运营商)缓存 --\x3e 根域名服务器 --\x3e 顶级域名服务器 --\x3e 主域名服务器")]),v._v("的顺序, 逐步读取缓存, 直到拿到IP地址"),_("br"),v._v("\nDNS Prefetch, DNS预解析就是根据浏览器定义的规则, 提前解析之后可能会用到的域名, 是解析结果缓存到系统缓存中, 缩短DNS解析时间, 提高网站访问速度\n"),_("ul",[_("li",[v._v("使用方法 "),_("code",[v._v('<link rel="dns-prefetch" href="https://...">')])])])]),v._v(" "),_("li",[v._v("并行连接"),_("br"),v._v("\n由于在http1.1协议下, chrome每个域名的最大并发数是6个, 使用多个域名,可以增加并发数")]),v._v(" "),_("li",[v._v("持久连接"),_("br"),v._v("\n使用keep-alive或presisitent来建立持久连接, 持久连接降低了时延和连接建立的开销. 将连接保持在已调谐状态, 减少打开连接的潜在数量")]),v._v(" "),_("li",[v._v("管道化连接"),_("br"),v._v("\n在http2协议中, 可以开启管道化连接, 即单条连接的多路复用, 每条连接中并发传输多个资源, 不需要添加域名的方式来增加并发数了.")])]),v._v(" "),_("h2",{attrs:{id:"优化资源加载"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优化资源加载"}},[v._v("#")]),v._v(" 优化资源加载")]),v._v(" "),_("ul",[_("li",[v._v("资源加载位置\n"),_("ul",[_("li",[v._v("通过优化资源加载位置,更改资源加载时机, 尽可能快的展示出页面内容\n"),_("ol",[_("li",[v._v("css文件放在head中, 先外链, 后本页")]),v._v(" "),_("li",[v._v("js文件放在body底部, 先外链, 后本页")]),v._v(" "),_("li",[v._v("处理页面布局的js文件放在head,")]),v._v(" "),_("li",[v._v("body中间尽量不写style标签, script标签")])])])])]),v._v(" "),_("li",[v._v("资源加载时机\n"),_("ul",[_("li",[v._v("异步加载script标签\n"),_("ul",[_("li",[v._v("defer: 异步加载, 在HTML解析完成后执行, defer的实际效果与将代码放在body底部类似")]),v._v(" "),_("li",[v._v("async: 异步加载, 加载完成后立即执行")])])]),v._v(" "),_("li",[v._v("模块按需加载  "),_("code",[v._v("import()语法, require.ensure")]),v._v("\n在SPA等业务逻辑比较复杂的系统中, 需要根据路由来加载当前页面需要的业务模块, 按需加载是一种很好的优化网页方式, 这种方式实际上先把代码在一些逻辑断点处分离开,然后在一些代码块中完成某些操作后, 立即引用或即将引用另外一些新的代码块, 这样加快了应用的初始加载速度, 减轻总体体积, 因为某些代码可能永远不会被加载")]),v._v(" "),_("li",[v._v("使用资源"),_("code",[v._v("预加载preload")]),v._v("和资源"),_("code",[v._v("预读取prefetch")]),v._v(" "),_("ul",[_("li",[v._v("preload让浏览器提前加载指定资源,需要执行时再执行, 可以加速本页面的加载速度")]),v._v(" "),_("li",[v._v("prefetch告诉浏览器加载下一页面可能会用到的资源, 可以加速下一个页面的加载速度")])])]),v._v(" "),_("li",[v._v("资源懒加载与资源预加载\n"),_("ul",[_("li",[v._v("资源延迟加载也称为懒加载, 延迟加载资源或符合某些条件时才加载某些资源")]),v._v(" "),_("li",[v._v("资源预加载是提前加载用户所需的资源, 保证良好的用户体验")]),v._v(" "),_("li",[v._v("懒加载和预加载都是一种错峰操作, 在浏览器忙的时候不做操作, 浏览器空闲时, 再加载资源. 优化了网络性能")])])])])])]),v._v(" "),_("h2",{attrs:{id:"减少重绘回流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#减少重绘回流"}},[v._v("#")]),v._v(" 减少重绘回流")]),v._v(" "),_("ul",[_("li",[v._v("样式设置\n"),_("ul",[_("li",[v._v("避免使用层级较深的选择器, 或其他一些复杂的选择器, 提高css渲染效率")]),v._v(" "),_("li",[v._v("避免使用css表达式, css表达式是动态设置css属性的强大但危险的方法, 他的问题在于计算频率很快, 不仅仅在页面显示和缩放时, 甚至于在页面滚动, 乃至移动鼠标时都要重新计算")]),v._v(" "),_("li",[v._v("元素适当的定义高度或最小高度, 否则元素的动态内容载入时, 会出现页面元素的晃动或位移, 造成回流")]),v._v(" "),_("li",[v._v("给图片设置尺寸, 如果不设置尺寸, 首次载入时, 占据空间会从0到完全出现, 上下左右都可能位移, 发生回流")]),v._v(" "),_("li",[v._v("不要使用table布局, 因为一个小改动可能会造成整个table重新布局, 而且table渲染通常要3倍于同等元素时间.")]),v._v(" "),_("li",[v._v("能够使用css实现的效果, 尽量使用css而不使用js实现")])])]),v._v(" "),_("li",[v._v("渲染层\n"),_("ul",[_("li",[v._v("将需要多次重绘的元素独立为render layer渲染层. 如设置absolute, 可以减少重绘范围")]),v._v(" "),_("li",[v._v("对于一些进行动画的元素. 使用硬件渲染. 从而避免重绘和回流")])])]),v._v(" "),_("li",[v._v("DOM优化\n"),_("ul",[_("li",[v._v("缓存dom, 由于查询DOM比较耗时, 在同一个节点无需多次查询的情况下, 可以缓存DOM")])]),v._v(" "),_("div",{staticClass:"language-js extra-class"},[_("pre",{pre:!0,attrs:{class:"language-js"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("const")]),v._v(" div "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" document"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[v._v("getElementById")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token string"}},[v._v("'div'")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("\n")])])]),_("ul",[_("li",[v._v("减少DOM深度与DOM数量, HTML中标签元素越多., 标签的层级越深, 浏览器解析DOM并绘制到浏览器中所花的时间就越长,所以应尽可能保持DOM元素简洁和层级较少")]),v._v(" "),_("li",[v._v("批量操作DOM, 由于DOM操作比较耗时,且可能会造成回流, 因此要避免频繁操作DOM. 可以批量操作DOM, 先用字符串拼接完毕, 再用innerHTML更新DOM")]),v._v(" "),_("li",[v._v("批量操作css样式, 通过切换class或者使用元素的style.csstext属性去批量操作元素的样式")]),v._v(" "),_("li",[v._v("在内存中操作dom, 使用DocumentFragment对象, 让DOM 操作发生在内存中, 而不是页面上")])]),v._v(" "),_("blockquote",[_("p",[v._v("DocumentFragment: 文档片段接口, 一个没有父对象的最小文档对象, 被用作一个轻量版的Document,就像标准的document一样, 存储由节点组成的文档结构.与Document相比, 最大的区别是DocumentFragment不是真实DOM树的一部分, 他的变化不会触发DOM树的重新渲染, 且不会导致性能问题, document.createDocumentFragment()")])]),v._v(" "),_("ul",[_("li",[v._v("DOM元素离线更新, 对DOM进行 相关操作时, 例appendChild等都可以使用Document Fragment对象进行离线操作, 待元素组装完成后再一次插入页面, 或者使用diplay: none对元素隐藏, 消失后进行操作")]),v._v(" "),_("li",[v._v("DOM读写分离, 浏览器具有惰性渲染机制, 连接多次修改DOM可能只触发浏览器的一次渲染, 而如果修改DOM后, 立即读取DOM, 为了保证读取到正确的DOM值. 会触发浏览器的一次渲染, 因此, 修改DOM的操作要与DOM分开进行")]),v._v(" "),_("li",[v._v("事件代理, 事件代理是指将事件监听器注册在父级元素上, 由于子元素的事件会通过事件冒泡的方式向上传播到父节点, 因此,可以由父节点的监听函数统一处理多个子元素的事件, 利用事件代理可以减少内存使用, 提高性能及降低代码复杂度")]),v._v(" "),_("li",[v._v("防抖和节流, 使用防抖或节流, 限制一个方法的频繁触发")]),v._v(" "),_("li",[v._v("及时消除对象引用, 清除定时器, 清除事件监听器, 创建最小作用域变量, 可以及时回收内存")])])])]),v._v(" "),_("h2",{attrs:{id:"性能更好的api"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#性能更好的api"}},[v._v("#")]),v._v(" 性能更好的API")]),v._v(" "),_("ul",[_("li",[v._v("用对选择器, 尽量选择性能更好的选择器, 性能排序: id选择器 > 类选择器 > 标签 > 相邻 > 子 > 后代 > 通配符 > 属性 > 伪类")]),v._v(" "),_("li",[v._v("使用requestAnimationFrame来替代setTimeout和setInterval: 目前只有使用requestAnimationFrame能够保证在每一帧刚开始的时候对页面进行更改, 使用setTimeout或者setInterval来触发更新页面的函数, 该函数可能在一阵的中间或者结束的时间点上调用, 进而导致该帧后面需要进行的事情没有完成, 导致丢帧")]),v._v(" "),_("li",[v._v("使用IntersectionObserver来实现图片可视区域的懒加载: 传统的做法, 需要使用scroll事件, 并调用getBoundingClintRect方法, 来实现可视区域的判断, 即使使用了函数节流, 也会造成页面回流, 使用IntersectionObserver则没有上诉问题.")])]),v._v(" "),_("blockquote",[_("p",[v._v("IntersetionObserver接口提供了一种异步观察目标元素与其祖先元素或顶级文档视窗交叉状态的方法. 祖先元素与视窗被称为根. 当一个IntersectionObserver对象被创建时, 其被配置为监听根中一段给定比例的可见区域, 一旦IntersectionObserver被创建, 则无法更改其配置, 所以一个给定的观察者对象只能用来监听可见区域的特定变化值, 然而 你可以在同一个观察者对象中配置监听多个目标元素.")])]),v._v(" "),_("ul",[_("li",[v._v("使用web worker: 客户端JavaScript一个基本的特性是单线程, 比如, 浏览器无法同事运行两个事件处理程序, 它也无法在一个事件处理程序运行时触发一个计时器, web worker是html5提供的一个JavaScript多线程解决方案, 可以将一些大计算量的代码交由web worker运行, 从而避阻塞用户界面, 在执行复杂计算和数据处理时, 这个API非常有用.")])]),v._v(" "),_("h2",{attrs:{id:"webpack优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#webpack优化"}},[v._v("#")]),v._v(" webpack优化")]),v._v(" "),_("ul",[_("li",[v._v("打包公共代码\n"),_("ul",[_("li",[v._v('使用CommonChunkPlugin插件, 将公共模块拆出来, 最终合成的文件能够在最开始的时候加载一次, 便存到缓存中供后续使用, 这会代理速度上的提升, webpack 4 移除了commonChunkPlugin, 取而代之的是两个新的配置项 optimization.splitChunks和 optimization.runtimeChunk, 通过设置optimization.splitChunks.chunks: "all" 来启动默认的代码分割配置项')])])]),v._v(" "),_("li",[v._v("动态导入和按需加载\n"),_("ul",[_("li",[v._v("优先选择 import(), 或使用webpack的 require.ensure")])])]),v._v(" "),_("li",[v._v("剔除无用代码\n"),_("ul",[_("li",[v._v("tree shaking是一个术语, 通常用于描述移除JavaScript上下文中的未引用代码, 它依赖于es2015模块系统中的静态结构特性, 例如import和export, 这个术语和概念兴起于rollup, JavaScript的tree shaking主要通过uglifyjs插件来完成, css的tree shaking主要通过purify CSS实现")])])]),v._v(" "),_("li",[v._v("长缓存优化\n"),_("ul",[_("li",[v._v("将hash替换为chunkhash, 这样当chunk不变时, 缓存依然有效")]),v._v(" "),_("li",[v._v("使用Name而不是ID: 每个module.id 会基于默认的解析顺序进行增量, 也就是说, 当解析顺序发生变化, ID也随之改变,　\n下面来使用两个插件解决这个问题。第一个插件是 NamedModulesPlugin，将使用模块的路径，而不是数字标识符。虽然此插件有助于在开发过程中输出结果的可读性，然而执行时间会长一些。第二个选择是使用 HashedModuleIdsPlugin，推荐用于生产环境构建")])])]),v._v(" "),_("li",[v._v("公用代码内联"),_("br"),v._v("\n　使用html-webpack-inline-chunk-plugin插件将mainfest.js内联到html文件中")])])])}),[],!1,null,null,null);e.default=l.exports}}]);