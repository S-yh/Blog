<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue | 随笔小记</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" href="favicon.ico">
    <meta name="description" content="石宇航的博客">
    <link rel="preload" href="/blog/assets/css/0.styles.42abb846.css" as="style"><link rel="preload" href="/blog/assets/js/app.6bc65339.js" as="script"><link rel="preload" href="/blog/assets/js/2.56432c1b.js" as="script"><link rel="preload" href="/blog/assets/js/29.35a166a5.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.b404adfe.js"><link rel="prefetch" href="/blog/assets/js/11.67ecfe53.js"><link rel="prefetch" href="/blog/assets/js/12.cf8d8beb.js"><link rel="prefetch" href="/blog/assets/js/13.0c1b465d.js"><link rel="prefetch" href="/blog/assets/js/14.18ec28dd.js"><link rel="prefetch" href="/blog/assets/js/15.eb0f3e64.js"><link rel="prefetch" href="/blog/assets/js/16.b8a3e666.js"><link rel="prefetch" href="/blog/assets/js/17.b7b03a4d.js"><link rel="prefetch" href="/blog/assets/js/18.09d0436c.js"><link rel="prefetch" href="/blog/assets/js/19.015944e6.js"><link rel="prefetch" href="/blog/assets/js/20.a2526c8c.js"><link rel="prefetch" href="/blog/assets/js/21.fc97d024.js"><link rel="prefetch" href="/blog/assets/js/22.a3e1ba11.js"><link rel="prefetch" href="/blog/assets/js/23.af659f66.js"><link rel="prefetch" href="/blog/assets/js/24.a9a5535e.js"><link rel="prefetch" href="/blog/assets/js/25.a58c0fc0.js"><link rel="prefetch" href="/blog/assets/js/26.bd130450.js"><link rel="prefetch" href="/blog/assets/js/27.c64a8768.js"><link rel="prefetch" href="/blog/assets/js/28.e2faf7b4.js"><link rel="prefetch" href="/blog/assets/js/3.c51900ee.js"><link rel="prefetch" href="/blog/assets/js/30.45faf144.js"><link rel="prefetch" href="/blog/assets/js/4.8059e4f4.js"><link rel="prefetch" href="/blog/assets/js/5.01321ecb.js"><link rel="prefetch" href="/blog/assets/js/6.e14d6673.js"><link rel="prefetch" href="/blog/assets/js/7.6b71f53f.js"><link rel="prefetch" href="/blog/assets/js/8.62d60ed2.js"><link rel="prefetch" href="/blog/assets/js/9.287114f8.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.42abb846.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">随笔小记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/note/" class="nav-link router-link-active">
  Note
</a></div><div class="nav-item"><a href="/blog/article/" class="nav-link">
  Article
</a></div><div class="nav-item"><a href="https://github.com/S-yh/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/note/" class="nav-link router-link-active">
  Note
</a></div><div class="nav-item"><a href="/blog/article/" class="nav-link">
  Article
</a></div><div class="nav-item"><a href="https://github.com/S-yh/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/note/html.html" class="sidebar-link">HTML</a></li><li><a href="/blog/note/css.html" class="sidebar-link">CSS</a></li><li><a href="/blog/note/js.html" class="sidebar-link">JavaScript</a></li><li><a href="/blog/note/vue.html" class="active sidebar-link">Vue</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/note/vue.html#vue实现原理" class="sidebar-link">vue实现原理:</a></li><li class="sidebar-sub-header"><a href="/blog/note/vue.html#响应式原理" class="sidebar-link">响应式原理</a></li><li class="sidebar-sub-header"><a href="/blog/note/vue.html#spa-单页面的理解" class="sidebar-link">SPA 单页面的理解</a></li><li class="sidebar-sub-header"><a href="/blog/note/vue.html#v-if-与-v-show" class="sidebar-link">v-if 与 v-show</a></li><li class="sidebar-sub-header"><a href="/blog/note/vue.html#class动态绑定" class="sidebar-link">class动态绑定</a></li><li class="sidebar-sub-header"><a href="/blog/note/vue.html#怎么理解vue单向数据流" class="sidebar-link">怎么理解Vue单向数据流</a></li><li class="sidebar-sub-header"><a href="/blog/note/vue.html#computed-和-watch" class="sidebar-link">Computed 和 watch</a></li><li class="sidebar-sub-header"><a href="/blog/note/vue.html#vue能检测到数组变化吗" class="sidebar-link">Vue能检测到数组变化吗</a></li><li class="sidebar-sub-header"><a href="/blog/note/vue.html#vue生命周期vue" class="sidebar-link">Vue生命周期Vue</a></li><li class="sidebar-sub-header"><a href="/blog/note/vue.html#vue-router" class="sidebar-link">Vue-Router</a></li><li class="sidebar-sub-header"><a href="/blog/note/vue.html#vue异步执行dom更新的" class="sidebar-link">Vue异步执行DOM更新的</a></li><li class="sidebar-sub-header"><a href="/blog/note/vue.html#响应式原理-2" class="sidebar-link">响应式原理</a></li><li class="sidebar-sub-header"><a href="/blog/note/vue.html#virtual-dom算法" class="sidebar-link">virtual DOM算法</a></li><li class="sidebar-sub-header"><a href="/blog/note/vue.html#v-model的原理" class="sidebar-link">v-model的原理</a></li><li class="sidebar-sub-header"><a href="/blog/note/vue.html#vuex" class="sidebar-link">vuex:</a></li><li class="sidebar-sub-header"><a href="/blog/note/vue.html#双向绑定的实现" class="sidebar-link">双向绑定的实现</a></li><li class="sidebar-sub-header"><a href="/blog/note/vue.html#vue项目优化" class="sidebar-link">Vue项目优化</a></li><li class="sidebar-sub-header"><a href="/blog/note/vue.html#vue底层实现原理" class="sidebar-link">vue底层实现原理</a></li><li class="sidebar-sub-header"><a href="/blog/note/vue.html#vue组件间通信方式" class="sidebar-link">Vue组件间通信方式</a></li><li class="sidebar-sub-header"><a href="/blog/note/vue.html#vue-3-0proxy与2-x-defineproperty" class="sidebar-link">vue 3.0proxy与2.x defineProperty</a></li><li class="sidebar-sub-header"><a href="/blog/note/vue.html#vue事件机制" class="sidebar-link">vue事件机制</a></li><li class="sidebar-sub-header"><a href="/blog/note/vue.html#vue-diff算法" class="sidebar-link">vue diff算法</a></li><li class="sidebar-sub-header"><a href="/blog/note/vue.html#vue自定义指令" class="sidebar-link">vue自定义指令</a></li><li class="sidebar-sub-header"><a href="/blog/note/vue.html#vue-ssr" class="sidebar-link">Vue SSR</a></li><li class="sidebar-sub-header"><a href="/blog/note/vue.html#computed和watch" class="sidebar-link">computed和watch</a></li></ul></li><li><a href="/blog/note/react.html" class="sidebar-link">React</a></li><li><a href="/blog/note/node.html" class="sidebar-link">Node</a></li><li><a href="/blog/note/ts.html" class="sidebar-link">TypeScript</a></li><li><a href="/blog/note/webpack.html" class="sidebar-link">Webpack</a></li><li><a href="/blog/note/git.html" class="sidebar-link">Git</a></li><li><a href="/blog/note/nginx.html" class="sidebar-link">Nginx</a></li><li><a href="/blog/note/linux.html" class="sidebar-link">Linux</a></li><li><a href="/blog/note/docker.html" class="sidebar-link">Docker</a></li><li><a href="/blog/note/browser.html" class="sidebar-link">浏览器</a></li><li><a href="/blog/note/snippet.html" class="sidebar-link">工具函数/代码片段</a></li><li><a href="/blog/note/algorithm.html" class="sidebar-link">数据结构/算法</a></li><li><a href="/blog/note/performance.html" class="sidebar-link">性能优化</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="vue实现原理"><a href="#vue实现原理" class="header-anchor">#</a> vue实现原理:</h2> <p>从入口开始 import Vue from 'vue'<br>
------------------------初始化-------------------------------首次构建</p> <ul><li>src/platforms/web/entry-runtime-with-compile.js :</li> <li>引入 Vue from src/platforms/web/runtime/index,</li> <li>缓存原型链上的$mount函数,</li> <li>并重写$mount(通过compileToFunctions将template编译为render函数),</li> <li>并调用缓存的mount函数</li> <li>src/platforms/web/runtime/index.js:</li> <li>引入 Vue from  src/core/index.js</li> <li>对Vue对象进行扩展, 包含定义$mount, 安装一个平台相关的 <strong>patch</strong> 等</li> <li>src/core/index.js:</li> <li>引入Vue from src/core/instance/index.js</li> <li>并调用initGlobalApi, 初始化全局 API</li> <li>src/core/instance/index.js:</li> <li>Vue构造函数, new Vue时, 执行构造函数内_init 函数</li> <li>src/core/instance/init.js:</li> <li>初始化主要是, 合并配置, 初始化生命周期, 事件中心, 渲染, data,props,computed, watcher等,</li> <li>最后检测如果有 el 属性, 则调用 vm.$mount方法进行实例挂载</li> <li>实例挂载:</li> <li>通过$mount方法去挂载vm,  src/platform/web/entry-runtime-with-compiler.js 定义的是带有compiler版本的$mount, 并缓存原型上的$mount,</li> <li>判断如果不存在render函数, 则调用compileToFunctions将template编译返回render函数,</li> <li>最后调用缓存的$mount函数</li> <li>定义在 src/platform/web/runtime/index.js在原型中的$mount方法:</li> <li>调用 mountComponent方法.</li> <li>定义在 src/core/instance/lifecycle.js中的mountComponent方法:</li> <li>核心是 实例化一个渲染Watcher, 传入updateComponent作为回调,</li> <li>updateComponent函数中会调用vm._render生成虚拟Node,</li> <li>将生成的VNode传入 vm._update 更新dom,</li> <li>Watcher在这里起到两个作用, 一个是初始化的时候执行回调, 另一个是当vm实例监测的数据发生变化时执行回调</li> <li>定义在src/core/instance/render.js中的 _render方法:</li> <li>主要是调用 在new Vue时传入的render方法,或编译template生成的render方法,</li> <li>并将vm.$createElement传入为参数,</li> <li>vm.$createElement是在 initRender时创建的, 内部调用了 createElement方法,</li> <li>render方法返回的是VNode(虚拟dom)</li> <li>定义在src/core/vdom/create-element.js 的createElement方法: 主要是生成vnode,</li> <li>实际是对_createElement方法的封装,真正创建VNode的函数,</li> <li>5个参数, context,上下文, tag: 标签, data, vnode数据, children vnode子节点, normalizationType: 子节点规范的类型.</li> <li>_createElement函数主要工作是: 规范化children为VNode类型的数组, 创建VNode 如果是内置节点, new VNode(), 如果是组件, createComponent创建组件类型VNode,</li> <li>定义在src/core/instance/lifecycle.js的_update</li> <li>作用是把VNode渲染成真实的DOM,</li> <li>调用时机有两个, 一个是首次渲染,一个是数据更新的时候,</li> <li>_update内部核心是调用vm.__patch__方法, 这个方法在浏览器端渲染时, 指向patch方法,</li> <li>定义在src/platform/web/runtime/patch.js中的patch方法,</li> <li>是createPatchFunction方法的返回值, 包含 nodeOps和 module两个参数</li> <li>createPatchFuncton是一个柯里化函数,</li> <li>patch方法本身接受4个参数, oldNode, 旧Vnode, vnode, 新vnode hydrating, 是否服务端渲染, removeOnly是给transition-group用的,</li> <li>经过一些复杂的逻辑后调用createElm函数</li> <li>createElm</li> <li>作用是通过虚拟节点创建真实的DOM并插入到它的父节点中,</li> <li>createComponent是尝试创建子组件,</li> <li>createChildren方法创建子元素, 实际上是遍历子虚拟节点, 递归调用createElm,</li> <li>深度优先遍历算法,</li> <li>至此真实dom渲染完成.</li> <li>整个过程 new Vue --&gt; init --&gt; $mount --&gt; compile --&gt; render --&gt; Vnode --&gt; patch --&gt; DOM</li></ul> <p>组件化</p> <ul><li>定义在src/core/vdom/create-component.js中的createComponent主要三个关键步骤,</li> <li>构造子类构造函数(baseCtor.extend(Ctor)), baseCtor实际上是Vue, Vue.extend(定义在src/core/global-api/extend.js)通过原型继承的方式把纯对象转换为一个继承于Vue的构造器Sub并返回, 然后扩展一些属性, 并初始化, 并缓存, 避免多次执行</li> <li>安装组件钩子函数, {init, prepatch, insert, destroy}合并到data.hook中, 在VNode执行patch的过程中执行相关的钩子函数,</li> <li>实例化VNode, 返回VNode</li> <li>patch中createElm创建组件的VNode,</li> <li>createComponent, 首先判断是组件VNode,会执行创建组件时合并的钩子函数, init钩子函数会 基于子类构造函数 vnode.componentOptions.Ctor() 创建一个实例.这个时机就是子组件的实例化,会执行this._init(), 并调用$mount函数,....</li> <li>接下来遍历VNode递归调用createElm, 如果遇到子VNode是组件的VNode,重复执行, 通过一个递归的方式完整的构建了整个组件树,</li> <li>在完成组件的整个patch过程后, 最后执行insert()完成dom插入, 如果组件patch过程又创建了子组件, 插入顺序是先子后父</li></ul> <p>合并配置</p> <ul><li>在vm._init(option)方法中会执行 mergeOption</li> <li>外部调用: 实际上是把 resolveConstructorOption(vm.constructor)的返回值(Vue.options)和options合并</li></ul> <p>生命周期
*</p> <p>组件注册
*</p> <p>异步组件
*</p> <h2 id="响应式原理"><a href="#响应式原理" class="header-anchor">#</a> 响应式原理</h2> <p>------------------------响应式原理-------------------------------
响应式原理Object.defineProperty</p> <ul><li>Object.defineProperty(obj, prop, descriptor)会直接在一个对象上定义一个新属性或修改一个对象的现有属性, 并返回这个属性</li> <li>initState: 在Vue初始化阶段, _init执行的时候, 会执行initState(vm)方法, 定义在 src/core/instance/state.js, initState方法主要是对props, methods, data,computed和watcher等属性做了初始化操作,</li> <li>initProps: 遍历定义的props配置,</li> <li>调用defineReactive方法把每个prop对应的值变成响应式, 可以通过vm._props.xx 访问到定义props中对应的属性,</li> <li>通过proxy把vm._props.xxx 的访问代理到vm.xxx 上</li> <li>initData: 遍历</li> <li>通过proxy把每一个值vm._data.xxx代理到vm.xxx,</li> <li>调用observe方法观测整个data的变化, 把data也变成响应式</li> <li>proxy: 代理的作用是把props和data上的属性代理到vm实例上,</li> <li>通过Object.defineProperty把target[source][key]的读写变成了对target[key]的读写,</li> <li>observe: 监测数据的变化, 定义在src/core/observe/index.js</li> <li>作用是给非VNode的对象类型数据添加一个Observer, 如果已经添加直接返回, ,否则去实例化一个Observer对象实例,</li> <li>Observer: 给对象添加getter和setter 用来依赖收集和派发更新</li> <li>实例化Dep, 执行def函数将自身实例添加到数据对象 value的__ob__属性上,</li> <li>判断value类型, 数组调用observeArray, 纯对象调用walk方法,</li> <li>observeArray是 遍历数组再次调用observe方法</li> <li>walk方法是遍历对象的key调用defineReactive方法</li> <li>defineReactive就是定义一个响应式对象, 给对象动态设置getter和setter, 定义在src/core/observer/index.js</li> <li>初始化Dep实例, 然后拿到obj的属性描述符, 对子属性递归调用observe, 保证子属性也能变成响应式的对象.</li> <li>依赖收集: 响应式对象getter相关的逻辑就是依赖收集</li> <li>定义在src/core.observer/dep.js 的 Dep类, 是整个getter依赖收集的核心, Dep有一个静态属性target, 这是全局唯一Watcher, Dep实际上就是对Watcher的一种管理, Dep脱离Watcher单独存在没有意义,</li> <li>过程分析; 当我们在mountComponent函数中, 实例化一个渲染watcher时, 首先进入Watcher的构造函数逻辑, 会执行他的this.get()方法, 方法里会执行pushTarget函数,实际是把Dep.target指向当前的渲染watcher,并压栈,接着执行 vm._update(vm._render(),hydrating), 会先执行vm._render(),这个方法会生成VNode, 并且这个过程会对vm上的数据访问, 这个时候就触发了数据对象的getter, 那么每一个对象值的getter都持有一个dep, 在触发getter的时候会调用dep.depend(), 把当前watcher订阅到这个数据持有的dep的subs中, 为了在后续数据变化时通知subs做准备,在vm._render()过程中, 会触发所有数据的getter,这样实际完成了一个依赖收集的过程, 之后再栈中恢复上一个状态, 并清空依赖</li> <li>派发更新: 收集依赖的目的就是为了当修改数据的时候</li> <li>defineReactive中 setter的逻辑有两个关键的点. 如果shallow为false,会对新设置的值为响应式对象, 另一个是dep.notify(), 通知所有的订阅者.</li> <li>过程分析: 当组件中的响应数据做了修改, 就会触发setter的逻辑, 最后调用dep.notify()方法, 这个方法主要是遍历所有subs, 也就是watcher实例数组, 然后调用每个watcher的update方法, update方法里会对不同状态的watcher执行不同的逻辑, 最后执行queueWatcher(this)的逻辑, 这里引入队列的概念, 使得它不会每次数据改变都触发watcher的回调, 而是把这些watcher先添加到一个队列里, 然后在nextTick后执行flushSchedulerQueue, flushSchedulerQueue函数主要先对队列排序, 然后遍历执行watcher.run(), run函数实际上就是执行this.getAndInvoke方法, 并传入watcher的回调函数, getAndInvoke主要逻辑是, 先通过this.get(), 得到他当前的值, 然后根据一些条件执行watcher回调函数, 对于watcher而言, 在执行this.get()求值时, 会执行getter方法, 也就是vm._update(vm._render(), hydrating), 所以这就是当我们去修改组件相关的响应式数据时, 会触发组件重新渲染的原因,接着就会重新执行patch过程.</li> <li>vm.$set是如何实现响应式的</li> <li>内部调用defineReactive, 并手动触发依赖通知 dep.notify()</li></ul> <h2 id="spa-单页面的理解"><a href="#spa-单页面的理解" class="header-anchor">#</a> SPA 单页面的理解</h2> <p>SPA (single-page application) 仅在Web页面初始化时加载相应的Html,JavaScript和Css,一旦加载完成,SPA不会因为用户的操作而进行重新加载或跳转;取而代之的是利用路由机制实现Html内容的变换,UI与用户的交互,避免页面的重新加载.</p> <ul><li>优点:</li> <li>用户体验好, 快</li> <li>服务器压力小</li> <li>前后端职责分离,架构清晰</li> <li>缺点</li> <li>初次加载耗时多</li> <li>不能使用浏览器前进后退功能</li> <li>SEO难度大,天然弱势</li></ul> <h2 id="v-if-与-v-show"><a href="#v-if-与-v-show" class="header-anchor">#</a> v-if 与 v-show</h2> <p>v-if是真正的条件渲染,直到第一次条件为真,才会开始渲染. v-show总是会被渲染,简单的基于css &quot;display&quot; 属性进行切换 v-if用于不频繁切换条件的场景,v-show用于频繁切换条件的场景</p> <h2 id="class动态绑定"><a href="#class动态绑定" class="header-anchor">#</a> class动态绑定</h2> <ul><li>对象语法 <code>&lt;div v-bind:class=&quot;{active: isActive, 'text-danger': hasError}&quot;&gt;&lt;/div&gt;</code></li> <li>数组语法 <code>&lt;div v-bind:class=&quot;[isActive: ? activeClass: '', errorClass]&quot;&gt;&lt;/div&gt;</code></li></ul> <h2 id="怎么理解vue单向数据流"><a href="#怎么理解vue单向数据流" class="header-anchor">#</a> 怎么理解Vue单向数据流</h2> <p>Vue 父子组件 prop之间形成了一个单向下行绑定, 父级prop的更新会向下流动到子组件中, 但是不能逆向流动, 这样可以防止子组件意外改变父组件的状态, 导致数据流向难以理解. 每次父组件发生更新时, 子组件的prop都会刷新微最新的值, 所以子组件内部不应改变prop,只能通过$emit派发一个自定义事件,通知父组件进行修改.</p> <h2 id="computed-和-watch"><a href="#computed-和-watch" class="header-anchor">#</a> Computed 和 watch</h2> <ul><li>computed 计算属性, 依赖其他属性值, 且只有它依赖的值发生改变, 才会重新计算</li> <li>watch 观察, 类似于监听, 每当数据变化时都会进行回调.</li></ul> <p>运用场景</p> <ul><li>当需要数值计算, 且依赖于其他属性时, 使用computed, 可避免重复计算.</li> <li>当需要在数据变化时, 执行异步操作或开销较大的操作时, 使用watch. 使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li></ul> <h2 id="vue能检测到数组变化吗"><a href="#vue能检测到数组变化吗" class="header-anchor">#</a> Vue能检测到数组变化吗</h2> <p>Vue不能检测到数组的变动, 可使用Vue.$set(array, indexOfArray, newValue) 或 Array.prototype.splice</p> <h2 id="vue生命周期vue"><a href="#vue生命周期vue" class="header-anchor">#</a> Vue生命周期Vue</h2> <p>开始创建 -&gt; 初始化数据 -&gt; 编译模板 -&gt; 挂载DOM -&gt; 渲染、更新 -&gt; 渲染、卸载
|beforeCreate| 组件实例被创建之初，组件的属性生效之前|
|created| 组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用|
|beforeMount| 在挂载开始之前被调用：相关的 render 函数首次被调用|
|mounted| el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子|
|beforeUpdate| 组件数据更新之前调用，发生在虚拟 DOM 打补丁之前|
|update| 组件数据更新之后|
|activited| keep-alive 专属，组件被激活时调用|
|deadctivated| keep-alive 专属，组件被销毁时调用|
|beforeDestory| 组件销毁前调用|
|destoryed| 组件销毁后调用</p> <h2 id="vue-router"><a href="#vue-router" class="header-anchor">#</a> Vue-Router</h2> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>vue-router: 这里的理由就是SPA的路径管理器, 路由模块的本质就是建立起url和页面之间的映射关系, SPA的核心之一就是--&gt;更新视图</p></div> <ul><li>hash模式:location.hash 单页应用. 每次hash值的变化, 触发hashchange事件, 通过这个事件可以知道hash值发生了哪些变化, 监听来实现页面的操作</li> <li>history模式: 通过 pushState, replaceState可以改变url地址且不发送请求, 同时还有popstate, 通过监听事件实现路由, 但是因为没有#号, 所以当用户刷新页面时,浏览器还是会发送请求,为了避免这些情况. 需要服务器的支持, 把所有路由重定向到根页面</li> <li>Vue.use执行install 方法安装vue-router插件</li> <li>混入 beforeCreate, destroyed</li> <li>注册全局组件 RouterView, RouterLink</li> <li>劫持Vue.prototype.$router, Vue.prototype.$route, 返回 this._routerRoot._router,this._routerRoot._route</li> <li>初始化router</li> <li>构造函数接收路由配置选项给this.options</li> <li>根据mode的不同实现不同的History类, 返回的实例赋值给this.history</li> <li>实例化Vue实例</li> <li>实例化router后, 在new Vue时把router作为配置属性传入, 那么在beforeCreate钩子中会执行 this._router.init(this), 传入了vue实例,存储到this.apps, 并根据this.history的不同执行不同逻辑,主要通过history.transitionTo方法</li> <li>history.transitionTo定义在History基类中，先通过match方法传入目标路由获取到描述目标路由的route对象，再调用confirmTransition函数执行跳转。而在VueRouter类中，可以看到match方法调用的实际上是matcher属性的match方法，而matcher是由createMatcher函数生成的.</li></ul> <h2 id="vue异步执行dom更新的"><a href="#vue异步执行dom更新的" class="header-anchor">#</a> Vue异步执行DOM更新的</h2> <ul><li>观察到数据变化, Vue开启一个队列, 并缓冲在同一事件循环中发生的所有数据改变</li> <li>如果同一个watcher被多次触发, 只会被推入到队列中一次, 这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作上非常必要</li> <li>然后, 在下一个事件循环tick中, Vue刷新队列并执行实际工作, Vue内部尝试对异步队列使用原生的Promise,then和MessageChannel, 如果执行环境不支持, 会采用setTimeout(fn,0)代替</li></ul> <h2 id="响应式原理-2"><a href="#响应式原理-2" class="header-anchor">#</a> 响应式原理</h2> <ul><li>如何追踪变化</li> <li>当你把一个普通的JavaScript对象传给Vue实例的data选项, Vue将遍历次对象所有的属性, 并使用Object.defineProperty把这些属性全部转为getter/setter</li> <li>Object.defineProperty 是ES5中一个无法shim的特性,所有不支持IE8及更低浏览器</li> <li>这些getter/setter对用户来说不可见, 但是在内部他们让Vue追踪依赖, 在属性被访问和修改时通知变化,</li> <li>每个组件实例都有对应的watcher实例对象, 他会在组件渲染的过程中把属性记录为依赖, 之后当依赖项的setter被调用时. 会通知watcher重新计算, 从而致使它关联的组件得以更新</li> <li>观察者订阅了可观察对象, 当可观察对象发布事件, 则就直接调度观察者的行为, 所以这里观察者和可观察对象其实就产生了一个依赖关系.</li></ul> <h2 id="virtual-dom算法"><a href="#virtual-dom算法" class="header-anchor">#</a> virtual DOM算法</h2> <ul><li>用JavaScript对象结构表示DOM树的结构, 然后用这个树构建真正的DOM树, 查到文档中</li> <li>当状态变更的时候, 重新构造一颗新的对象树, 然后用这个新和旧的树进行比较, 记录两棵树的差异,</li> <li>把记录的差异应用到所构建的真正的DOM树上, 视图就更新了</li></ul> <p>比较两颗DOM树的差异是virtual DOM算法最核心的部分, 这也是所谓的Virtual DOM的diff算法, 两个数的完全的diff算法是一个时间复杂度为O(n^3)的问题, 但是在前端当中, 你很少会跨越层级的移动DOM元素, 所以Virtual DOM diff只会对同一个层级的元素进行对比, 这样算法复杂度, 可以达到O(n) . 在实际的代码中. 会对新旧两颗树进行一个深度优先的遍历, 这样每个节点有会有一个唯一的标记, 在深度优先遍历的时候. 每遍历一个节点就把该节点和新的树进行对比, 如果有差异的话就记录到一个对象里面, virtual DOM diff 算法主要是实现上面步骤的三个函数, element, diff, patch</p> <h2 id="v-model的原理"><a href="#v-model的原理" class="header-anchor">#</a> v-model的原理</h2> <ul><li>v-model在内部为不同的输入元素使用不同的属性, 并抛出不同的事件,</li> <li>text和textarea元素使用value, input事件</li> <li>CheckBox和radio使用checked change事件</li> <li>select字段将value作为prop并将change作为事件</li></ul> <h2 id="vuex"><a href="#vuex" class="header-anchor">#</a> vuex:</h2> <p>一个专为vue.js 应用程序开发的状态管理模式, 每一个Vuex应用的核心就是store, store基本上是一个容器, 他包含着你的应用大部分的状态,</p> <ul><li>vuex的状态存储是响应式的 ,  当vue组件从store中读取状态时, 若store中的状态发生变化, 那么响应的组件也会响应的得到高效更新</li> <li>改变store中的状态的唯一途径就是现实的提交mutation, 这样我们可以方便的跟踪每一个状态的变化</li></ul> <h2 id="双向绑定的实现"><a href="#双向绑定的实现" class="header-anchor">#</a> 双向绑定的实现</h2> <ul><li><p>实现一个监听器Observer, 对数据对象进行遍历, 包括子属性对象的属性, 利用Object.defineProperty, 对属性都加上setter和getter,这样的话, 给这个对象的某个值复制, 就会触发setter, 那么就能监听到了数据变化.</p></li> <li><p>实现一个解析器Compile, 解析Vue模板指令, 将模板中的变量都替换成数据, 然后初始化渲染页面视图, 并将每个指令对应的节点绑定更新函数, 添加监听数据的订阅者, 一旦数据有变动, 收到通知, 调用更新函数进行数据更新</p></li> <li><p>实现一个订阅者Watcher, watcher订阅者是Observer和compile之间通信的桥梁, 主要的任务是订阅Observer中的属性变化的消息,当收到属性值变化的消息是, 触发解析器, Compile中对应的更新函数</p></li> <li><p>实现一个订阅器Dep, 订阅器采用发布订阅设计模式, 用来收集订阅者watcher, 对监听器Observer和订阅者, watcher进行统一管理</p></li> <li><p>响应式原理:</p></li></ul> <p>Vue在初始化阶段会给定义在data中的每一项添加一个Observer, Observer主要是实例化Dep,用来依赖收集,然后遍历数据对象的key调用defineReactive方法,defineReactive就是定义一个响应式对象,通过Object.defineProperty给对象动态设置setter和gettergetter的逻辑主要就是依赖收集, 依赖收集的核心就是Dep类, Dep有一个静态属性target是全局唯一Watcher, Dep实际就是对Watcher的管理,依赖收集的过程主要是在mountComponent(挂载阶段)中, 实例化一个watcher, 并将Dep.target指向当前watcher,并压栈,接着执行vm._update(vm._render()),也就是生成虚拟dom(render)以及把虚拟dom渲染成真实dom(patch),这个过程会访问vue实例(vm)上的数据,触发getter每一个对象都有一个dep实例, 触发getter时会调用dep.depend(), 把当前watcher订阅到这个dep的subs中. 为了在后续数据变化时通知subs.setter的逻辑主要是派发更新, 过程主要是 当响应数据被修改就会触发setter,会调用dep.notify(),这个方法主要是遍历所有subs,也就是watcher实例数组.中间会将watcher添加到队列, 在nextTick后调用watcher.run(),主要工作是得到当前的值(this.get()),然后执行watcher回调函数,在获取当前值的时候会触发getter, 也就会触发render,patch,使组件重新渲染.</p> <h2 id="vue项目优化"><a href="#vue项目优化" class="header-anchor">#</a> Vue项目优化</h2> <ol><li>代码层面的优化</li></ol> <ul><li>v-if 和 v-show 区分使用场景</li> <li>computed 和 watch 区分使用场景</li> <li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li> <li>长列表性能优化</li> <li>事件的销毁</li> <li>图片资源懒加载</li> <li>路由懒加载</li> <li>第三方插件的按需引入</li> <li>优化无限列表性能</li> <li>服务端渲染 SSR or 预渲染</li></ul> <ol start="2"><li>Webpack 层面的优化</li></ol> <ul><li>Webpack 对图片进行压缩</li> <li>减少 ES6 转为 ES5 的冗余代码</li> <li>提取公共代码</li> <li>模板预编译</li> <li>提取组件的 CSS</li> <li>优化 SourceMap</li> <li>构建结果输出分析</li> <li>Vue 项目的编译优化</li></ul> <ol start="3"><li>基础的 Web 技术的优化</li></ol> <ul><li>开启gzip压缩</li> <li>浏览器缓存,</li> <li>cdn</li></ul> <h2 id="vue底层实现原理"><a href="#vue底层实现原理" class="header-anchor">#</a> vue底层实现原理</h2> <ul><li>vue.js 是采用数据劫持结合发布者-订阅者模式的方式, 通过Object.definePorperty()来劫持各个属性的setter和getter,在数据变动的时候发布消息给订阅者, 触发相应的监听回调.</li> <li>实现这种双向绑定需要三大模块</li> <li>Observer(数据监听器): Observer的核心是通过Object.defineProperty()来监听数据的变动, 这个函数内部可以定义setter和getter, 当数据变化时, 触发setter, 这时Observer通知订阅者, Watcher</li> <li>Watcher(订阅者): Watcher订阅者作为Observer和Compile之间的桥梁, 主要做的事是</li> <li>在自身实例化时往属性订阅器(dep)里面添加自己</li> <li>自身有一个update方法</li> <li>待属性变动dep.notice()通知时, 能调用自身的update方法. 并触发Compile绑定的回调函数</li> <li>Compile(指令解析器): Compile主要做的事情就是解析模板指令, 将模板中变量替换成数据, 然后初始化渲染页面视图, 并将每个指令对应的节点绑定更新函数, 添加监听数据的订阅者, 一旦数据变动, 收到通知, 更新视图</li></ul> <h2 id="vue组件间通信方式"><a href="#vue组件间通信方式" class="header-anchor">#</a> Vue组件间通信方式</h2> <ul><li>props/ $emit</li> <li>$emit/ $on(事件总线): 利用空的Vue实例</li> <li>vuex</li> <li>$attrs/ $listeners</li> <li>$attrs: 包含了父作用域中不被prop所识别(且获取)的特性绑定(class和style除外). 当一个组件没有声明任何prop时, 包含所有父作用域的绑定, 可以通过v-bind=&quot;$attrs&quot;传入子组件</li> <li>$listeners: 包含了父作用域中的v-on事件监听器(不含 .native修饰器的), 他可以通过v-on=&quot;$listeners&quot;传入内部组件</li> <li>provide/inject : 允许一个祖先组件想其子孙后代注入一个依赖, 祖先组件中通过provide来提供变量, 然后在子孙组件通过inject注入变量, provide/inject主要解决跨级组件间的通信问题, 主要使用场景是子组件获取上级组件的状态, 跨级组件间建立了一种主动提供与依赖注入的关系</li> <li>$parent/ $children与 ref</li> <li>ref: 如果用在普通DOM元素上, 引用指向的就是DOM元素, 如果用在子组件上, 引用就是指向组件实例</li> <li>$parent/ $children 访问父/子实例</li></ul> <h2 id="vue-3-0proxy与2-x-defineproperty"><a href="#vue-3-0proxy与2-x-defineproperty" class="header-anchor">#</a> vue 3.0proxy与2.x defineProperty</h2> <ul><li>defineProperty:</li> <li>无法监听数组的变化, 数组没有setter和getter(可使用vm.$set(array, index, value),  vm.array.splice(index, num, value)实现监听)</li> <li>只能劫持对象的属性(使用vm.$set(object, key, value)实现监听)</li> <li>proxy:</li> <li>直接监听对象, 而不是属性</li> <li>可以监听数组的变化</li> <li>proxy有多大13种拦截办法,</li> <li>返回一个新对象</li> <li>兼容问题大</li></ul> <h2 id="vue事件机制"><a href="#vue事件机制" class="header-anchor">#</a> vue事件机制</h2> <ul><li>初始化事件,</li> <li>Vue初始化时, initEvents方法在vm上创建一个_events对象, 用来存放事件, 就下来调用initState方法, 接下来Vue将html解析成AST 将事件绑定到target元素上</li> <li>$on, 用来监听一个自定义事件, 可用$emit触发</li> <li>$once监听只能触发一次的事件, 触发后会自动移除</li> <li>$off用来移除自定义事件</li> <li>$emit 用来触发自定义事件</li></ul> <h2 id="vue-diff算法"><a href="#vue-diff算法" class="header-anchor">#</a> vue diff算法</h2> <p>patch方法中</p> <ul><li>patch函数有两个参数oldNode，Vnode</li> <li>首先判断sameNode（oldnode，vnode）：主要根据tag，key等</li> <li>如果判断不值得比较，直接（vnode）替换oldNode</li> <li>如果判断值得比较，执行patchNode（oldNode，Vnode），这个函数主要工作</li> <li>找到真实dom</li> <li>判断oldNode和vnode是否指向同一个对象，是则return</li> <li>如果他们都有文本节点且不相等，将el文本节点设置为Vnode文本节点</li> <li>如果oldVnode有子节点而Vnode没有，则删除el的子节点</li> <li>如果oldNode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el</li> <li>如果两者都有子节点，则执行updateChildren函数比较子节点</li> <li>updateChildren函数</li> <li>将Vnode的子节点和oldNode的子节点提取出来</li> <li>oldChild和vchild各有两个头尾的变量startIdx和endIdx，它们的两个变量相互比较，一共有四种方式，如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较过程中，变量会往中间靠，一旦startIdx大于endIdx表明oldChild和vchild至少有一个遍历结束，就会结束比较，如果oldChild遍历先结束，则把vnode剩余的直接插入到相应的index位置，如果vchild先结束，删除oldchild剩余的真实dom</li></ul> <h2 id="vue自定义指令"><a href="#vue自定义指令" class="header-anchor">#</a> vue自定义指令</h2> <ul><li>全局指令:</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'focus'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">inserted</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>局部指令:</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>directives<span class="token operator">:</span> <span class="token punctuation">{</span>
    focus<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function-variable function">inserted</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><p>钩子函数(可选):</p> <ul><li>bind: 只调用一次. 指令第一次绑定到元素时调用. 在这里可以进行一次性的初始化设置</li> <li>inserted: 被绑定元素插入父节点时调用. (仅保证父节点存在, 不一定被插入文档)</li> <li>update:所在组件的vnode更新时调用. 但是可能发生在其子vnode更新之前, 指令的值可能发生了改变. 也可能没有, 但是你可以通过比较更新前后的值来忽略不必要的模板更新</li> <li>componentUpdated: 指令所在组件的VNode及其子vnode全部更新后调用</li> <li>unbind:只调用一次. 指令与元素解绑时调用</li></ul></li> <li><p>钩子函数参数</p> <ul><li>el: 指令所绑定的元素,可以用来直接操作dom</li> <li>bingding: 一个对象, 包含以下属性
<ul><li>name: 指令名</li> <li>value: 指定的绑定值</li> <li>oldValue: 指令绑定的前一个值</li> <li>expression: 字符串形式的指令表达式</li> <li>arg: 传给指令的参数</li> <li>modifiers: 一个包含修饰符的对象</li></ul></li> <li>vnode: vue编译生成的虚拟节点</li> <li>oldVnode: 上一个虚拟节点</li></ul></li></ul> <h2 id="vue-ssr"><a href="#vue-ssr" class="header-anchor">#</a> Vue SSR</h2> <blockquote><p>优势</p></blockquote> <ul><li>更好的SEO, 由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面</li> <li>更快的内容到达时间,更好的用户体验.</li></ul> <blockquote><p>限制</p></blockquote> <ul><li>开发条件限制: 只能使用某些生命周期钩子函数.</li> <li>服务器渲染应用程序,需要处于nodejs运行环境</li> <li>更多的服务器端负载.</li></ul> <h2 id="computed和watch"><a href="#computed和watch" class="header-anchor">#</a> computed和watch</h2> <p>computed：计算属性</p> <p>计算属性是由data中的已知值，得到的一个新值。
这个新值只会根据已知值的变化而变化，其他不相关的数据的变化不会影响该新值。
计算属性不在data中，计算属性新值的相关已知值在data中。
别人变化影响我自己。</p> <p>watch：监听数据的变化</p> <p>监听data中数据的变化
监听的数据就是data中的已知值
我的变化影响别人</p> <p>1.watch擅长处理的场景：一个数据影响多个数据</p> <p>2.computed擅长处理的场景：一个数据受多个数据影响</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/note/js.html" class="prev">
        JavaScript
      </a></span> <span class="next"><a href="/blog/note/react.html">
        React
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.6bc65339.js" defer></script><script src="/blog/assets/js/2.56432c1b.js" defer></script><script src="/blog/assets/js/29.35a166a5.js" defer></script>
  </body>
</html>
