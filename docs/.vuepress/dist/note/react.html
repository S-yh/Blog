<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React | 随笔小记</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" href="favicon.ico">
    <meta name="description" content="石宇航的博客">
    <link rel="preload" href="/blog/assets/css/0.styles.8ffcef68.css" as="style"><link rel="preload" href="/blog/assets/js/app.3ee478e8.js" as="script"><link rel="preload" href="/blog/assets/js/2.56432c1b.js" as="script"><link rel="preload" href="/blog/assets/js/9.07fd45dd.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.b596a7c9.js"><link rel="prefetch" href="/blog/assets/js/11.67ecfe53.js"><link rel="prefetch" href="/blog/assets/js/12.32c9f23f.js"><link rel="prefetch" href="/blog/assets/js/13.83c7673a.js"><link rel="prefetch" href="/blog/assets/js/14.efa744b0.js"><link rel="prefetch" href="/blog/assets/js/15.3e13135c.js"><link rel="prefetch" href="/blog/assets/js/16.c2fabd3c.js"><link rel="prefetch" href="/blog/assets/js/17.353f150a.js"><link rel="prefetch" href="/blog/assets/js/18.7691b37d.js"><link rel="prefetch" href="/blog/assets/js/19.572a326b.js"><link rel="prefetch" href="/blog/assets/js/20.db79418f.js"><link rel="prefetch" href="/blog/assets/js/21.2761f514.js"><link rel="prefetch" href="/blog/assets/js/22.0c87893a.js"><link rel="prefetch" href="/blog/assets/js/23.307d1628.js"><link rel="prefetch" href="/blog/assets/js/24.372551c7.js"><link rel="prefetch" href="/blog/assets/js/25.a6823745.js"><link rel="prefetch" href="/blog/assets/js/26.b515ea84.js"><link rel="prefetch" href="/blog/assets/js/27.07859db9.js"><link rel="prefetch" href="/blog/assets/js/28.5d8f599a.js"><link rel="prefetch" href="/blog/assets/js/29.b0376bb4.js"><link rel="prefetch" href="/blog/assets/js/3.6923e039.js"><link rel="prefetch" href="/blog/assets/js/30.915c7998.js"><link rel="prefetch" href="/blog/assets/js/31.ced6bba1.js"><link rel="prefetch" href="/blog/assets/js/32.27231a72.js"><link rel="prefetch" href="/blog/assets/js/33.54f78435.js"><link rel="prefetch" href="/blog/assets/js/34.a707596c.js"><link rel="prefetch" href="/blog/assets/js/35.5bfe4c73.js"><link rel="prefetch" href="/blog/assets/js/4.d82d9895.js"><link rel="prefetch" href="/blog/assets/js/5.edab269e.js"><link rel="prefetch" href="/blog/assets/js/6.45f43810.js"><link rel="prefetch" href="/blog/assets/js/7.b59499a4.js"><link rel="prefetch" href="/blog/assets/js/8.25923ad3.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.8ffcef68.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">随笔小记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/note/" class="nav-link router-link-active">
  Note
</a></div><div class="nav-item"><a href="/blog/article/" class="nav-link">
  Article
</a></div><div class="nav-item"><a href="https://github.com/S-yh/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/note/" class="nav-link router-link-active">
  Note
</a></div><div class="nav-item"><a href="/blog/article/" class="nav-link">
  Article
</a></div><div class="nav-item"><a href="https://github.com/S-yh/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/note/html.html" class="sidebar-link">HTML</a></li><li><a href="/blog/note/css.html" class="sidebar-link">CSS</a></li><li><a href="/blog/note/js.html" class="sidebar-link">JavaScript</a></li><li><a href="/blog/note/vue.html" class="sidebar-link">Vue</a></li><li><a href="/blog/note/react.html" class="active sidebar-link">React</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/note/react.html#redux" class="sidebar-link">Redux</a></li><li class="sidebar-sub-header"><a href="/blog/note/react.html#redux-saga" class="sidebar-link">redux-saga</a></li><li class="sidebar-sub-header"><a href="/blog/note/react.html#fiber-核心调度算法" class="sidebar-link">Fiber(核心调度算法)</a></li><li class="sidebar-sub-header"><a href="/blog/note/react.html#virtual-dom" class="sidebar-link">virtual DOM</a></li><li class="sidebar-sub-header"><a href="/blog/note/react.html#render-的作用" class="sidebar-link">render()的作用</a></li><li class="sidebar-sub-header"><a href="/blog/note/react.html#react中key的作用" class="sidebar-link">react中key的作用</a></li><li class="sidebar-sub-header"><a href="/blog/note/react.html#hoc-render-props-hook" class="sidebar-link">HOC, render props, hook</a></li><li class="sidebar-sub-header"><a href="/blog/note/react.html#react-diff" class="sidebar-link">react diff</a></li><li class="sidebar-sub-header"><a href="/blog/note/react.html#setstate的同步与异步" class="sidebar-link">setState的同步与异步</a></li><li class="sidebar-sub-header"><a href="/blog/note/react.html#受控组件和非受控组件" class="sidebar-link">受控组件和非受控组件</a></li><li class="sidebar-sub-header"><a href="/blog/note/react.html#react生命周期" class="sidebar-link">react生命周期.</a></li><li class="sidebar-sub-header"><a href="/blog/note/react.html#react的事件机制" class="sidebar-link">react的事件机制</a></li><li class="sidebar-sub-header"><a href="/blog/note/react.html#react事件要绑定this" class="sidebar-link">React事件要绑定this</a></li><li class="sidebar-sub-header"><a href="/blog/note/react.html#原生事件与react事件" class="sidebar-link">原生事件与react事件</a></li><li class="sidebar-sub-header"><a href="/blog/note/react.html#react的合成事件-syntheticevent" class="sidebar-link">react的合成事件(SyntheticEvent)</a></li><li class="sidebar-sub-header"><a href="/blog/note/react.html#react和原生事件的执行顺序" class="sidebar-link">react和原生事件的执行顺序</a></li><li class="sidebar-sub-header"><a href="/blog/note/react.html#react组件渲染流程" class="sidebar-link">react组件渲染流程</a></li><li class="sidebar-sub-header"><a href="/blog/note/react.html#代码一定需要引入react" class="sidebar-link">代码一定需要引入react</a></li><li class="sidebar-sub-header"><a href="/blog/note/react.html#react组件首字母都需要大写" class="sidebar-link">React组件首字母都需要大写</a></li><li class="sidebar-sub-header"><a href="/blog/note/react.html#react渲染真实dom做了哪些性能优化" class="sidebar-link">react渲染真实dom做了哪些性能优化</a></li><li class="sidebar-sub-header"><a href="/blog/note/react.html#为什么hook只能在顶层调用" class="sidebar-link">为什么hook只能在顶层调用</a></li><li class="sidebar-sub-header"><a href="/blog/note/react.html#jsx" class="sidebar-link">JSX</a></li></ul></li><li><a href="/blog/note/node.html" class="sidebar-link">Node</a></li><li><a href="/blog/note/ts.html" class="sidebar-link">TypeScript</a></li><li><a href="/blog/note/webpack.html" class="sidebar-link">Webpack</a></li><li><a href="/blog/note/git.html" class="sidebar-link">Git</a></li><li><a href="/blog/note/nginx.html" class="sidebar-link">Nginx</a></li><li><a href="/blog/note/linux.html" class="sidebar-link">Linux</a></li><li><a href="/blog/note/docker.html" class="sidebar-link">Docker</a></li><li><a href="/blog/note/browser.html" class="sidebar-link">浏览器</a></li><li><a href="/blog/note/snippet.html" class="sidebar-link">工具函数/代码片段</a></li><li><a href="/blog/note/algorithm.html" class="sidebar-link">数据结构/算法</a></li><li><a href="/blog/note/performance.html" class="sidebar-link">性能优化</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="redux"><a href="#redux" class="header-anchor">#</a> Redux</h2> <ul><li>Store: 保存数据的地方, 整个应用只能有一个Store, Redux提供createStore用来生成Store</li> <li>State: Store对象包含所有数据, 如果想要得到某个时点的数据, 就要对Store生成快照, 这个时点的数据集合就叫做State. 当前时刻State可以通过 store.getState()得到</li> <li>Action: Action是一个对象, type属性是必须的, 表示Action的名称, Action描述当前发生的事情, 改变State的唯一办法,就是使用Action</li> <li>store.dispatch(): 是view发出Action的唯一方法, store.dispatch 接受一个Action参数, 将他发送出去</li> <li>Reducer: Store收到Action以后, 必须给出一个新的state,这种State的计算过程就叫做Reducer, Reducer是一个函数, 接受Action和当前state作为参数, 返回一个新的state。在createStore函数中传入Reducer作为参数, 生成一个新的Store,每当store.dispatch发过来Action时, 就会自动调用Reducer,得到新的state</li> <li>store.subscribe(): Store允许使用store.subscribe()方法设置监听, 一旦State发生变化, 自动执行这个函数, 接受一个监听函数作为参数, 并返回一个函数, 调用可以解除监听</li> <li>combineReducers: 用于Reducer的拆分, 只要定义各个子Reducer函数. 然后使用这个函数将他们合并为一个大的Reducer</li></ul> <h2 id="redux-saga"><a href="#redux-saga" class="header-anchor">#</a> redux-saga</h2> <p>redux-saga 是一个用于管理应用程序副作用的库, redux-saga是一个redux中间件, 意味着这个县城可以通过正常的redux action从主应用程序启动, 暂停, 和取消,他能完整的访问state,也可以dispatch redux action,  redux-saga使用了es6的Generator功能</p> <ul><li>执行过程:
<ul><li>通过takeEvery(或takeLatest)监听某个action. 一旦发起action, 则会执行takeEvery第二个参数传入的相关异步操作(异步过程中通过调用call等函数).然后通过put函数通知store结果.</li></ul></li></ul> <h2 id="fiber-核心调度算法"><a href="#fiber-核心调度算法" class="header-anchor">#</a> Fiber(核心调度算法)</h2> <ul><li>Fiber是线程的颗粒化的一个概念. 一个线程可以包含多个Fiber</li> <li>Fiber是大量的同步计算可以被拆解,异步化 使浏览器主线程得以调控, 包含以下权限
<ul><li>暂停运行任务</li> <li>恢复并继续执行任务</li> <li>给不同的任务分配不同的优先级</li></ul></li> <li>原理:
<ul><li>将一个state更新需要执行的同步任务拆分成一个Fiber任务队列</li> <li>在任务队列中选出优先级高的Fiber执行, 如果执行时间超过了deathLine,则设置为pending状态挂机</li> <li>一个Fiber执行结束或挂起, 或调用基于 requestIdleCallback/requestAnimationFrame实现的调度器,返回一个新的Fiber任务队列继续进行上述过程</li> <li>requestIdleCallback会让一个低优先级的任务在空闲期被调用，而requestAnimationFrame会让一个高优先级的任务在下一个栈帧被调用，从而保证了主线程按照优先级执行Fiber单元。</li> <li>由此我们可以看出Fiber任务的优先级顺序为：
<ul><li>文本框输入 &gt; 本次调度结束需完成的任务 &gt; 动画过渡 &gt; 交互反馈 &gt; 数据更新 &gt; 不会显示但以防将来会显示的任务</li></ul></li></ul></li></ul> <h2 id="virtual-dom"><a href="#virtual-dom" class="header-anchor">#</a> virtual DOM</h2> <p>virtual dom 是一个轻量级的JavaScript对象, 他最初只是real DOM的副本, 是一个节点树, 将元素,及他们的属性和内容最为对象及其属性, React的渲染函数从React组件中创建一个节点树, 然后它响应数据模型中的变化来更新该树, 该变化是由用户或系统完成的各种动作引起的.</p> <ul><li>virtual DOM 工作过程
<ul><li>每当底层数据发生改变时, 整个UI都将在Virtual DOM 描述中重新渲染.</li> <li>然后计算Z之前DOM表示与新表示之间的差异(diff)</li> <li>完成计算后, 将只用实际更改的内容更新real DOM</li></ul></li> <li>虚拟dom比普通dom更快吗
<ul><li>如果是首次渲染, 虚拟dom不具有任何优势, 甚至要进行更多的计算, 消耗更多的内存,</li> <li>虚拟dom的优势在于 react diff算法和批处理策略, react在页面更新之前, 计算好如何进行更新和渲染, 这个点其实是所谓的虚拟dom提升性能的点.</li> <li>虚拟dom并不是比dom操作更快, 而是在重复渲染的时候帮助计算如何更高效的更新</li></ul></li></ul> <h2 id="render-的作用"><a href="#render-的作用" class="header-anchor">#</a> render()的作用</h2> <p>每个组件强制要求必须有一个render(), 他返回一个React元素, 是原生dom组件的表示, 如果要渲染多个HTML元素, 则必须将他们在一个封闭标记内, 此函数必须保持纯净</p> <h2 id="react中key的作用"><a href="#react中key的作用" class="header-anchor">#</a> react中key的作用</h2> <ul><li>react利用key来识别组件, 它是一种身份标识, 每个key对应一个组件, 相同的key, react会认为是同一个组件, 这样后续相同的key对应的组件都不会被创建</li> <li>key属性是添加到自定义的子组件上，而不是子组件内部的顶层的组件上。</li> <li>key值的唯一是有范围的，即在数组生成的同级同类型的组件上要保持唯一，而不是所有组件的key都要保持唯一</li> <li>react利用key来区分组件的，相同的key表示同一个组件，react不会重新销毁创建组件实例，只可能更新；key不同，react会销毁已有的组件实例，重新创建组件新的实例。</li></ul> <h2 id="hoc-render-props-hook"><a href="#hoc-render-props-hook" class="header-anchor">#</a> HOC, render props, hook</h2> <ul><li>HOC: 创建一个函数, 该函数接收一个组件作为输入, 基于该组件返回了一个不同的组件
<ul><li>优点: 不会影响内层组件的状态, 降低了耦合度</li> <li>缺点: 固定的props可能会被覆盖, 无法清晰地标识数据的来源</li></ul></li> <li>render props:  接收一个外部传递进来的props属性,  将内部的state作为参数传递给调用组件的props属性方法
<ul><li>缺点:无法在return语句外访问数据, 容易导致嵌套地域</li></ul></li> <li>应用场景:
<ul><li>日志打点,</li> <li>权限控制</li> <li>双向绑定</li> <li>表单校验</li></ul></li> <li>hook
<ul><li>hook可以重命名</li> <li>hook会清晰的标注来源</li> <li>hook可以在return外使用</li> <li>hook不会嵌套</li></ul></li></ul> <h2 id="react-diff"><a href="#react-diff" class="header-anchor">#</a> react diff</h2> <ul><li>原理: 树是递归的数据结构, 时间复杂度,O(n^3), react只比较同一层, 一旦不一样, 删除, 这样每一个节点只会比较一次, 所以算法时间复杂度变成O(n), 对于同一层的一组子节点, 他们有可能顺序发生改变, 但是内容没有变化, react根据key值来进行区分,一旦key值相同, 就直接返回之前的组件, 不重新创建,</li></ul> <h2 id="setstate的同步与异步"><a href="#setstate的同步与异步" class="header-anchor">#</a> setState的同步与异步</h2> <p>取决于是在react批处理之前还是之后, 之前是异步, 之后是同步</p> <ul><li>setState在原生事件和setTimeout中都是同步的, 在合成事件和钩子函数 中是异步的,</li> <li>在setState中, 会根据一个isBatchingUpdates判断是直接更新还是稍后更新, 他的默认值是false, 但是React在调用事件处理函数之前会先调用batchedUpdates这个函数, batchedUpdates函数回将isBatchingUpdates设置为true, 因此由react控制的事件处理过程就变成了异步,(批量更新)</li></ul> <h2 id="受控组件和非受控组件"><a href="#受控组件和非受控组件" class="header-anchor">#</a> 受控组件和非受控组件</h2> <ul><li>受控组件: 受状态控制,  必须有onChange方法, 可以赋予默认值, 状态改变的时候会被写进组件的state中</li> <li>非受控组件: 不受状态控制. 组件没有value prop, 通常需要通过ref来访问底层DOM</li></ul> <h2 id="react生命周期"><a href="#react生命周期" class="header-anchor">#</a> react生命周期.</h2> <ul><li>初始化阶段: constructor, getDefaultProps, getInitialState</li> <li>挂载阶段: componentWillMount, render, componentDidMount</li> <li>更新阶段: componentWillReceiveProps, shouldComponentUpdate, componentWillUpdate, render, componentDidUpdate,</li> <li>卸载阶段: componentWillUnmount</li></ul> <h2 id="react的事件机制"><a href="#react的事件机制" class="header-anchor">#</a> react的事件机制</h2> <ul><li>React事件没有绑定在真实的Dom节点上, 而是通过事件代理, 在最外层的document上对事件进行统一分发
<img src="/blog/assets/img/event.7b91f444.png" alt="事件机制"></li></ul> <h2 id="react事件要绑定this"><a href="#react事件要绑定this" class="header-anchor">#</a> React事件要绑定this</h2> <ul><li>React在documen上进行统一的事件分发, dispatchEvent通过循环调用所有层级的事件来模拟事件冒泡和捕获, 在react中. 当某一事件处理函数要调用时, 将调用invokeGuardedCallback方法, 在内部事件处理函数是直接调用的, 并没有指定调用的组件, 所以不进行手动绑定的情况下直接获取到的this是不准确的, 所以需要手动将当前组件绑定到this上</li></ul> <h2 id="原生事件与react事件"><a href="#原生事件与react事件" class="header-anchor">#</a> 原生事件与react事件</h2> <ul><li>React事件使用驼峰命名, 而不是全小写</li> <li>通过JSX, 你传递一个函数作为事件处理程序, 而不是一个字符串</li> <li>在react中不能通过返回false来阻止默认行为, 必须明确调用preventDefault</li></ul> <h2 id="react的合成事件-syntheticevent"><a href="#react的合成事件-syntheticevent" class="header-anchor">#</a> react的合成事件(SyntheticEvent)</h2> <ul><li>react根据W3C规范定义了每个事件处理函数的参数, 即合成事件</li> <li>事件处理程序将传递SyntheticEvent的实例, 这是一个跨浏览器原生事件包装器, 它具有与浏览器原生事件相同的接口, 包括stopPropagetion, preventDefault, 在所有浏览器中他们的工作方式都相同.,  react合成的SyntheticEvent,采用了事件池, 节省内存,</li></ul> <h2 id="react和原生事件的执行顺序"><a href="#react和原生事件的执行顺序" class="header-anchor">#</a> react和原生事件的执行顺序</h2> <ul><li>react的事件都是通过document进行统一分发, 当真实dom触发事件后冒泡到document后才会对react事件进行处理,</li> <li>原生的事件会先执行, 然后执行react的合成事件, 最后执行真正在document挂载的事件,</li> <li>react事件和原生事件最好不混用, 原生事件如果执行了stopPropagation方法, 则会导致其他react事件失效, 因为所有元素的事件将无法冒泡到document上, 导致所有react事件都会无法触发</li></ul> <h2 id="react组件渲染流程"><a href="#react组件渲染流程" class="header-anchor">#</a> react组件渲染流程</h2> <ul><li>使用React.createElement或JSX编写React组件, 实际上jsx代码最终都会转换成React.createElement, Babel帮助完成转换</li> <li>createElement函数对key和ref等特殊的props进行处理, 并获取defaultProps对默认props赋值, 并对children节点进行处理, 最终构成一个ReactElement对象(虚拟dom)</li> <li>ReactDom.render()将生成的虚拟dom渲染到指定的容器上, 其中采用了批处理, 事务等机制,并且对特定浏览器进行了性能优化, 最终转换成真实dom</li></ul> <h2 id="代码一定需要引入react"><a href="#代码一定需要引入react" class="header-anchor">#</a> 代码一定需要引入react</h2> <ul><li>jsx只是为React.createElement(component, props, ...children)方法提供的语法糖,所有jsx代码最后都会转换成React.CreateElement,babel进行转译,</li></ul> <h2 id="react组件首字母都需要大写"><a href="#react组件首字母都需要大写" class="header-anchor">#</a> React组件首字母都需要大写</h2> <ul><li>babel在编译时会判断jsx组件的首字母, 小写时会被认定为原生dom标签, createElement第一个变量会被编译为字符串, 大写时被认定为自定义组件, createElement的第一个变量编译为对象</li></ul> <h2 id="react渲染真实dom做了哪些性能优化"><a href="#react渲染真实dom做了哪些性能优化" class="header-anchor">#</a> react渲染真实dom做了哪些性能优化</h2> <ul><li>在IE, Edge中, 一个一个插入子孙节点, 效率高于插入一整个序列化的节点树</li> <li>react通过lazyTree,在IE,Edge进行单个节点依次渲染节点, 而在其他浏览器则首先将整个大的DOM结构建好,整体插入容器</li></ul> <h2 id="为什么hook只能在顶层调用"><a href="#为什么hook只能在顶层调用" class="header-anchor">#</a> 为什么hook只能在顶层调用</h2> <p>我们可以在组件中使用多个state Hook或 Effect Hook, 但是React如何知道state对应哪个useState? React是根据Hook的调用顺序来追踪state的. Hook在每次渲染中的调用顺序保持相同, React就能正确地将内部state和对应的Hook进行关联.</p> <h2 id="jsx"><a href="#jsx" class="header-anchor">#</a> JSX</h2> <p>JSX --&gt; Babel --&gt; React.createElement --&gt; ReactElement --&gt; virtual DOM --&gt; ReactDOM.render --&gt; real DOM</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/note/vue.html" class="prev">
        Vue
      </a></span> <span class="next"><a href="/blog/note/node.html">
        Node
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.3ee478e8.js" defer></script><script src="/blog/assets/js/2.56432c1b.js" defer></script><script src="/blog/assets/js/9.07fd45dd.js" defer></script>
  </body>
</html>
