<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue Composition API | 随笔小记</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" href="favicon.ico">
    <meta name="description" content="石宇航的博客">
    <link rel="preload" href="/blog/assets/css/0.styles.8ffcef68.css" as="style"><link rel="preload" href="/blog/assets/js/app.1f7d68ac.js" as="script"><link rel="preload" href="/blog/assets/js/2.56432c1b.js" as="script"><link rel="preload" href="/blog/assets/js/19.088aacf8.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.b49d1246.js"><link rel="prefetch" href="/blog/assets/js/11.67ecfe53.js"><link rel="prefetch" href="/blog/assets/js/12.47a27093.js"><link rel="prefetch" href="/blog/assets/js/13.6b0400fe.js"><link rel="prefetch" href="/blog/assets/js/14.0cd542e0.js"><link rel="prefetch" href="/blog/assets/js/15.5ea5cd73.js"><link rel="prefetch" href="/blog/assets/js/16.86b4d97c.js"><link rel="prefetch" href="/blog/assets/js/17.353f150a.js"><link rel="prefetch" href="/blog/assets/js/18.9a6fbcee.js"><link rel="prefetch" href="/blog/assets/js/20.3fe2a7f8.js"><link rel="prefetch" href="/blog/assets/js/21.d9050399.js"><link rel="prefetch" href="/blog/assets/js/22.e07e9042.js"><link rel="prefetch" href="/blog/assets/js/23.0280c117.js"><link rel="prefetch" href="/blog/assets/js/24.88075e69.js"><link rel="prefetch" href="/blog/assets/js/25.3c6da112.js"><link rel="prefetch" href="/blog/assets/js/26.c80ecee6.js"><link rel="prefetch" href="/blog/assets/js/27.5ad9aba2.js"><link rel="prefetch" href="/blog/assets/js/28.bd00fd7e.js"><link rel="prefetch" href="/blog/assets/js/29.5952eb97.js"><link rel="prefetch" href="/blog/assets/js/3.6923e039.js"><link rel="prefetch" href="/blog/assets/js/30.5d32358c.js"><link rel="prefetch" href="/blog/assets/js/31.b5d74357.js"><link rel="prefetch" href="/blog/assets/js/32.10d8980a.js"><link rel="prefetch" href="/blog/assets/js/33.ff44929b.js"><link rel="prefetch" href="/blog/assets/js/34.3195be40.js"><link rel="prefetch" href="/blog/assets/js/35.5bfe4c73.js"><link rel="prefetch" href="/blog/assets/js/4.47307dd4.js"><link rel="prefetch" href="/blog/assets/js/5.725e8389.js"><link rel="prefetch" href="/blog/assets/js/6.a4e7f8f5.js"><link rel="prefetch" href="/blog/assets/js/7.17d4b1a1.js"><link rel="prefetch" href="/blog/assets/js/8.36ff7d92.js"><link rel="prefetch" href="/blog/assets/js/9.a1654909.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.8ffcef68.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">随笔小记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/note/" class="nav-link">
  Note
</a></div><div class="nav-item"><a href="/blog/article/" class="nav-link router-link-active">
  Article
</a></div><div class="nav-item"><a href="https://github.com/S-yh/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/note/" class="nav-link">
  Note
</a></div><div class="nav-item"><a href="/blog/article/" class="nav-link router-link-active">
  Article
</a></div><div class="nav-item"><a href="https://github.com/S-yh/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/article/vue-ssr.html" class="sidebar-link">Vue SSR</a></li><li><a href="/blog/article/redux.html" class="sidebar-link">Redux</a></li><li><a href="/blog/article/vuex.html" class="sidebar-link">Vuex</a></li><li><a href="/blog/article/react-hook.html" class="sidebar-link">React Hooks</a></li><li><a href="/blog/article/vue-composition-api.html" class="active sidebar-link">Vue Composition API</a></li><li><a href="/blog/article/event-loop.html" class="sidebar-link">Event Loop</a></li><li><a href="/blog/article/typescript.html" class="sidebar-link">TypeScript</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue-组合式-api"><a href="#vue-组合式-api" class="header-anchor">#</a> Vue 组合式 API</h1> <h2 id="响应式与副作用"><a href="#响应式与副作用" class="header-anchor">#</a> 响应式与副作用</h2> <p>创建一个响应式的状态:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span>reactive<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    count<span class="token operator">:</span> <span class="token number">0</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p><code>reactive</code> 几乎等价于2.x中现有的<code>Vue.observable()</code>API,这里返回的<code>state</code>是一个响应式对象.</p> <blockquote><p>在Vue中, 响应式状态的基本用力就是在渲染时使用它, 因为有了依赖追踪, 视图会在响应式状态发生改变时自动更新</p></blockquote> <p>在DOM当中渲染内容被视为一种<strong>副作用</strong>, 程序会在外部修改其本身的状态, 使用<code>watchEffect</code>API应用基于响应式状态的副作用, 并自动进行重应用.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> reactive<span class="token punctuation">,</span> watchEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    count<span class="token operator">:</span> <span class="token number">0</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerHtml <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">count is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>state<span class="token punctuation">.</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p><code>watchEffec</code> 接收一个应用预期副作用的函数, 它会立即执行该函数, 并将该执行过程中用到的所有响应式状态的property作为依赖进行追踪.</p> <h2 id="计算状态与ref"><a href="#计算状态与ref" class="header-anchor">#</a> 计算状态与Ref</h2> <p>有一些状态依赖于其他状态的状态(衍生状态), 在Vue中通过<strong>计算属性</strong>来处理, 在Vue Composition API中可以使用<code>computed</code>API直接创建一个计算值.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> reactive<span class="token punctuation">,</span> computed <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> double <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>
</code></pre></div><p><code>computed</code> 内部简单实现.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token parameter">getter</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token punctuation">{</span>
        value<span class="token operator">:</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
    <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        ref<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> ref
<span class="token punctuation">}</span>
</code></pre></div><p>另外需要劫持对这个对象<code>.value</code>属性的读写操作,来实现依赖收集与更新通知. 返回的<code>Ref</code>对象用来作为一个响应式引用保留内部的值.除了计算值的ref, 还可以使用<code>ref</code>API直接创建一个可变更的普通ref.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="解开ref"><a href="#解开ref" class="header-anchor">#</a> 解开Ref</h2> <p>ref值可以暴露给渲染上下文, 在渲染过程中, Vue会直接使用其内部的值, 也就是说在模板中可以把<code>count.value</code>直接写成<code>count</code>, 当一个ref值嵌套与响应式对象中时,访问会自动解开</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    double<span class="token operator">:</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>double<span class="token punctuation">)</span>
</code></pre></div><p>在组件中的使用方式</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>increment<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    Count is: {{state.count}}, double is: {{state.double}}
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    <span class="token keyword">import</span> <span class="token punctuation">{</span> reactive<span class="token punctuation">,</span> computed <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>
    <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
        <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
                count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
                double<span class="token operator">:</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
            <span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                state<span class="token punctuation">.</span>count<span class="token operator">++</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token punctuation">{</span>
                state<span class="token punctuation">,</span> increment
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h2 id="声明周期钩子函数"><a href="#声明周期钩子函数" class="header-anchor">#</a> 声明周期钩子函数</h2> <p>为了在声明周期钩子中产生副作用, 我们可以使用形如 <code>onXXX</code>的API</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> onMounted <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Mounted'</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这些声明周期方法只能用在<code>setup</code>钩子中, 它会通过内部的全局状态自动找到调用此<code>setup</code>钩子的实例, 如此设计是为了减少将逻辑提取到外部函数时的冲突.</p> <h2 id="ref-vs-reactive"><a href="#ref-vs-reactive" class="header-anchor">#</a> Ref vs. Reactive</h2> <ul><li><code>ref</code>的使用时为了让基础类型值具有响应式,</li> <li>使用<code>reactive</code>的问题是, 使用组合函数时必须始终保持对这个所返回对象的引用, 以保持响应式, 不能解构或展开</li> <li>使用<code>toRefs</code>API 可以将<code>reactive</code>返回的响应式对象的每个property都转成响应的ref. 可以展开或解构</li></ul> <p>两种变量风格</p> <ul><li>类似于在js中声明基础类型变量与对象变量时一样区别使用<code>ref</code>和<code>reactive</code></li> <li>所有地方都使用<code>reactive</code>, 然后在组合函数返回的时候对响应式对象使用<code>toRefs</code>.</li></ul> <h2 id="主要api"><a href="#主要api" class="header-anchor">#</a> 主要API</h2> <h3 id="setup"><a href="#setup" class="header-anchor">#</a> <code>setup</code></h3> <p><code>setup</code>函数是一个新的组件选项, 作为组件内使用Composition API的入口点.</p> <ul><li>调用时机: 创建组件实例, 然后初始化<code>props</code>, 紧接着就调用<code>setup</code>函数, 从生命周期钩子的视角来看, 它会在<code>beforeCreate</code>钩子之前调用</li> <li>模板中使用: 如果<code>setup</code>返回一个对象, 则对象的属性将会被合并到组件模板的渲染上下文.</li></ul> <blockquote><p><code>setup</code>返回的ref在模板中会自动解开,不需要写<code>.value</code></p></blockquote> <ul><li>渲染函数/JSX中使用
<code>setup</code>也可以返回一个函数, 函数中也能使用当前<code>setup</code>函数作用域中的响应式数据</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> h<span class="token punctuation">,</span> ref<span class="token punctuation">,</span> reactive <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">const</span> objec <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>foo<span class="token operator">:</span> <span class="token string">'bar'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">.</span>value<span class="token punctuation">,</span> object<span class="token punctuation">.</span>foo<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><p>参数:</p> <ol><li><code>setup</code>函数接收<code>props</code>作为第一个参数, <code>props</code>对象是响应式的, <code>watchEffect</code>或<code>watch</code>会观察和响应<code>props</code>的更新, <code>props</code>对象不可以解构,会失去响应式.</li> <li><code>setup</code>函数接收<code>context</code>作为第二个参数, 暴露了一些property, 可以解构使用.</li></ol></li> <li><p><code>this</code>在<code>setup</code>中不可用</p></li> <li><p>类型定义</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">Data</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>key<span class="token operator">:</span> string<span class="token punctuation">]</span><span class="token operator">:</span> unknown
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token operator">:</span> Data</span><span class="token punctuation">)</span><span class="token operator">:</span> Data
</code></pre></div><h3 id="reactive"><a href="#reactive" class="header-anchor">#</a> <code>reactive</code></h3> <p><code>reactive</code>接收一个普通对象, 然后返回该普通对象的响应式代理. 响应式转换是深层的, 会影响对象内部所有嵌套的属性, 基于es2015的proxy实现, 返回的代理对象不等于原始对象.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>count<span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="ref"><a href="#ref" class="header-anchor">#</a> <code>ref</code></h3> <p><code>ref</code>接受一个参数值, 并返回一个响应式且可改变的ref对象. ref对象拥有一个指向内部值的单一属性<code>.value</code>. 如果传入ref的是一个对象, 将调用<code>reactive</code>方法进行深层响应转换.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 0</span>
count<span class="token punctuation">.</span>value<span class="token operator">++</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 1</span>
</code></pre></div><ul><li>当ref作为渲染上下文的属性返回, 在模板中使用时, 会自动解开, 无需额外输入<code>.value</code></li> <li>当ref作为reactive对象的property被访问和修改时, 也自动解开,</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    count
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token comment">// 0</span>
state<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 1</span>
</code></pre></div><blockquote><p>当嵌套在reactive Object中时, ref才会解套, 从Array或Map等原生集合访问ref时, 不会自动解套</p></blockquote> <h3 id="computed"><a href="#computed" class="header-anchor">#</a> <code>computed</code></h3> <p>传入一个getter函数, 返回一个默认不可手动修改的ref对象.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> plusOne <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> count<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>plusOne<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 2</span>

plusOne<span class="token punctuation">.</span>value<span class="token operator">++</span> <span class="token comment">// 报错</span>
</code></pre></div><p>传入一个拥有<code>get</code>和<code>set</code>函数的对象,可创建一个可以手动更改的计算状态</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> plusOne <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> count<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        count<span class="token punctuation">.</span>value <span class="token operator">=</span> val <span class="token operator">-</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="readonly"><a href="#readonly" class="header-anchor">#</a> <code>readonly</code></h3> <p>传入一个对象或ref, 返回一个原始对象的<strong>只读</strong>代理, 一个只读代理是深层的, 对象内部任何嵌套的属性也是只读的.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> original <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> copy <span class="token operator">=</span> <span class="token function">readonly</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span>

</code></pre></div><h3 id="watcheffect"><a href="#watcheffect" class="header-anchor">#</a> <code>watchEffect</code></h3> <p>立即执行传入的函数, 并响应式追踪其依赖. 并在其依赖变更时重新运行该函数.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>停止监听
当<code>watchEffect</code>在组件的<code>setup</code>函数或生命周期被调用时, 侦听器会被链接到该组件的声明周期, 并在组件卸载时自动停止. 在一些情况下也可以显示调用返回值以停止监听</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> stop <span class="token operator">=</span> <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>清除副作用
<code>watchEffect</code>传入的函数可以接受一个<code>onInvalidate</code>函数作入参, 用来注册清理失效时的回调.当以下情况发生时, 这个<strong>失效回调</strong>会被触发.
<ul><li><code>watchEffect</code>函数即将重新执行</li> <li>侦听器被停止, 也就是上文说到的停止监听情况.</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token parameter">onInvalidate</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> token <span class="token operator">=</span> <span class="token function">asyncOperation</span><span class="token punctuation">(</span>id<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
    <span class="token comment">// id改变 或 停止监听时.</span>
    <span class="token function">onInvalidate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        token<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>副作用刷新时机
Vue会缓存副作用函数, 并异步刷新, 可以避免同一个tick中多个状态改变, 导致重复调用. 核心的具体实现是, 组件的更新函数也是一个被监听的副作用, 当副作用函数进入队列时, 会在所有组件更新后执行.</li></ul> <blockquote><p>注意: 初始化运行是在组件<code>mounted</code>之前执行的, 如果希望在编写副作用函数时访问dom或模板ref,请在<code>onMounted</code>中进行.</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 这里可以访问到DOM或者 template refs</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>如果副作用函数需要同步在组件更新之前重新执行, 可以传递一个拥有<code>flush</code>属性的对象作为选项, 默认为<code>post</code>, 同步为<code>sync</code>, 更新之前运行为<code>pre</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 同步运行</span>
<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>flush<span class="token operator">:</span> <span class="token string">'sync'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 组件更新之前运行</span>
<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>flush<span class="token operator">:</span> <span class="token string">'pre'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>侦听器调试
<code>onTrack</code>和<code>onTrigger</code>选项可用于调试侦听器的行为
<ul><li>当一个reactive对象属性或一个ref作为依赖被追踪时, 将调用<code>onTrack</code></li> <li>依赖项变更导致副作用被触发时, 调用<code>onTrigger</code>
这两个回调都接受一个包含有关依赖项信息的调试器事件.</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span>
    <span class="token function">onTrigger</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">debugger</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="watch"><a href="#watch" class="header-anchor">#</a> <code>watch</code></h3> <p><code>watch</code>等效于 2.x中的<code>watch选项</code>, watch需要侦听特定的数据源, 并在回调函数中执行副作用. 默认情况是懒执行的.</p> <ul><li><p>与<code>watchEffect</code>相比, <code>watch</code>可以</p> <ul><li>懒执行副作用</li> <li>更明确依赖的状态</li> <li>访问侦听状态变化前后的值</li></ul></li> <li><p>侦听数据源
侦听器的数据源可以是一个拥有返回值的getter函数, 也可以是ref</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 侦听一个getter</span>
<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span>state<span class="token punctuation">.</span>count<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">count<span class="token punctuation">,</span>preCount</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// 侦听一个ref</span>
<span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token function">watch</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">count<span class="token punctuation">,</span>preCount</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 侦听多个数据源</span>
<span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">[</span>fooRef<span class="token punctuation">,</span>barRef<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span>foo<span class="token punctuation">,</span> bar<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>preFoo<span class="token punctuation">,</span> preBar<span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="生命周期钩子函数"><a href="#生命周期钩子函数" class="header-anchor">#</a> 生命周期钩子函数</h3> <p><code>onMounted</code>, <code>onUpdated</code>, <code>onUnmounted</code>. 这些钩子注册函数只能在<code>setup</code>期间同步使用. 因为他们依赖于内部的全局状态来定位当前组件实例, 组件实例上下文也是在生命周期钩子同步执行期间设置的, 因此, 在卸载组件时, 在生命周期钩子内部同步创建的侦听器和计算状态也将自动删除</p> <ul><li>与2.x生命周期相对相应的组合式API</li></ul> <table><thead><tr><th>2.x</th> <th>composition API</th></tr></thead> <tbody><tr><td>beforeCreate</td> <td>使用 setup()</td></tr> <tr><td>created</td> <td>使用 setup()</td></tr> <tr><td>beforeMount</td> <td>onBeforeMount</td></tr> <tr><td>mounted</td> <td>onMounted</td></tr> <tr><td>beforeUpdate</td> <td>onBeforeUpdate</td></tr> <tr><td>updated</td> <td>onUpdated</td></tr> <tr><td>beforeDestroy</td> <td>onBeforeUnmount</td></tr> <tr><td>destroyed</td> <td>onUnmounted</td></tr> <tr><td>errorCaptured</td> <td>onErrorCaptured</td></tr></tbody></table> <ul><li>新增的钩子函数
<ul><li>onRenderTracked</li> <li>onRenderTriggered
两个函数都接受一个<code>DebuggerEvent</code>,与<code>watchEffect</code>参数选项中的<code>onTrack</code>和<code>onTrigger</code>蕾西</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    <span class="token function">onRenderTriggered</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 检查哪个依赖项导致组件重新渲染. </span>
        <span class="token keyword">debugger</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="依赖注入"><a href="#依赖注入" class="header-anchor">#</a> 依赖注入</h3> <p><code>provide</code>和<code>inject</code>提供依赖注入, 且只能在当前活动组件实例的<code>setup</code>调用.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> provide<span class="token punctuation">,</span> inject <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">const</span> ThemeSymbol <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> Ancestor <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">provide</span><span class="token punctuation">(</span>ThemeSymbol<span class="token punctuation">,</span> <span class="token string">'dark'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> descendent <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> theme <span class="token operator">=</span> <span class="token function">inject</span><span class="token punctuation">(</span>ThemeSymbol<span class="token punctuation">,</span> <span class="token string">'light'</span> <span class="token comment">/* optional default value */</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span>
            theme
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>inject</code> 接受一个可选的默认值作为第二个参数, 如果未提供默认值, 并且在provide上下文中未找到该属性, 则<code>inject</code>返回<code>undefined</code></p> <ul><li>注入的响应式.
可以使用ref来保证<code>provide</code>和<code>inject</code>之间值的响应, 如果注入一个响应式对象, 他的状态变化也可以被监听</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 提供者：</span>
<span class="token keyword">const</span> themeRef <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">'dark'</span><span class="token punctuation">)</span>
<span class="token function">provide</span><span class="token punctuation">(</span>ThemeSymbol<span class="token punctuation">,</span> themeRef<span class="token punctuation">)</span>

<span class="token comment">// 使用者：</span>
<span class="token keyword">const</span> theme <span class="token operator">=</span> <span class="token function">inject</span><span class="token punctuation">(</span>ThemeSymbol<span class="token punctuation">,</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">'light'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">theme set to: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>theme<span class="token punctuation">.</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="模板refs"><a href="#模板refs" class="header-anchor">#</a> 模板Refs</h3> <p>当使用组合式API时, reactive refs和template refs的概念是统一的. 为了获得对模板元素或组件实例的引用, 可以在setup中声明一个ref并返回它.</p> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>root<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    <span class="token keyword">import</span> <span class="token punctuation">{</span> ref<span class="token punctuation">,</span> onMounted <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>
    <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
        <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// &lt;div&gt;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token punctuation">{</span>
                root
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/article/react-hook.html" class="prev">
        React Hooks
      </a></span> <span class="next"><a href="/blog/article/event-loop.html">
        Event Loop
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.1f7d68ac.js" defer></script><script src="/blog/assets/js/2.56432c1b.js" defer></script><script src="/blog/assets/js/19.088aacf8.js" defer></script>
  </body>
</html>
