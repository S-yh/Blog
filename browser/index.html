<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>常见的浏览器内核 | 随笔一记</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" href="favicon.ico">
    <meta name="description" content="石宇航的博客">
    <link rel="preload" href="/blog/assets/css/0.styles.b9ccaafe.css" as="style"><link rel="preload" href="/blog/assets/js/app.00e18691.js" as="script"><link rel="preload" href="/blog/assets/js/2.db07618b.js" as="script"><link rel="preload" href="/blog/assets/js/5.b7c661e0.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.edbb1189.js"><link rel="prefetch" href="/blog/assets/js/11.8f420a2d.js"><link rel="prefetch" href="/blog/assets/js/12.3d7a24af.js"><link rel="prefetch" href="/blog/assets/js/13.f19b14f8.js"><link rel="prefetch" href="/blog/assets/js/14.06ca3dbb.js"><link rel="prefetch" href="/blog/assets/js/15.a58a2385.js"><link rel="prefetch" href="/blog/assets/js/16.5db12838.js"><link rel="prefetch" href="/blog/assets/js/17.72730d08.js"><link rel="prefetch" href="/blog/assets/js/18.9c417147.js"><link rel="prefetch" href="/blog/assets/js/3.e019d799.js"><link rel="prefetch" href="/blog/assets/js/4.f4dcefd4.js"><link rel="prefetch" href="/blog/assets/js/6.d89921ae.js"><link rel="prefetch" href="/blog/assets/js/7.4a75d29b.js"><link rel="prefetch" href="/blog/assets/js/8.8e180344.js"><link rel="prefetch" href="/blog/assets/js/9.d5ef3708.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.b9ccaafe.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">随笔一记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/S-yh/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/S-yh/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/html/" class="sidebar-link">HTML</a></li><li><a href="/blog/css/" class="sidebar-link">CSS</a></li><li><a href="/blog/js/" class="sidebar-link">JavaScript</a></li><li><a href="/blog/vue/" class="sidebar-link">Vue</a></li><li><a href="/blog/react/" class="sidebar-link">React</a></li><li><a href="/blog/node/" class="sidebar-link">Node</a></li><li><a href="/blog/git/" class="sidebar-link">Git</a></li><li><a href="/blog/webpack/" class="sidebar-link">Webpack</a></li><li><a href="/blog/docker/" class="sidebar-link">Docker</a></li><li><a href="/blog/browser/" class="active sidebar-link">浏览器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/browser/#常见的浏览器内核" class="sidebar-link">常见的浏览器内核</a></li><li class="sidebar-sub-header"><a href="/blog/browser/#对浏览器内核的理解" class="sidebar-link">对浏览器内核的理解</a></li><li class="sidebar-sub-header"><a href="/blog/browser/#v8引擎" class="sidebar-link">v8引擎</a></li><li class="sidebar-sub-header"><a href="/blog/browser/#post和get区别" class="sidebar-link">post和get区别</a></li><li class="sidebar-sub-header"><a href="/blog/browser/#敲入url到渲染完成的整个过程" class="sidebar-link">敲入URL到渲染完成的整个过程</a></li><li class="sidebar-sub-header"><a href="/blog/browser/#深入理解https" class="sidebar-link">深入理解https</a></li><li class="sidebar-sub-header"><a href="/blog/browser/#浏览器缓存实现原理" class="sidebar-link">浏览器缓存实现原理</a></li><li class="sidebar-sub-header"><a href="/blog/browser/#http协议头字段" class="sidebar-link">http协议头字段</a></li><li class="sidebar-sub-header"><a href="/blog/browser/#jwt-json-web-token" class="sidebar-link">JWT(JSON Web Token)</a></li><li class="sidebar-sub-header"><a href="/blog/browser/#xss与csp" class="sidebar-link">Xss与CSP</a></li><li class="sidebar-sub-header"><a href="/blog/browser/#http字段" class="sidebar-link">http字段</a></li><li class="sidebar-sub-header"><a href="/blog/browser/#跨域解决方案" class="sidebar-link">跨域解决方案</a></li><li class="sidebar-sub-header"><a href="/blog/browser/#tcp三次握手-四次挥手" class="sidebar-link">TCP三次握手, 四次挥手</a></li><li class="sidebar-sub-header"><a href="/blog/browser/#移动端点击事件" class="sidebar-link">移动端点击事件</a></li><li class="sidebar-sub-header"><a href="/blog/browser/#事件委托-事件代理" class="sidebar-link">事件委托(事件代理):</a></li><li class="sidebar-sub-header"><a href="/blog/browser/#webrtc-实时通讯技术" class="sidebar-link">WebRTC: 实时通讯技术.</a></li></ul></li><li><a href="/blog/snippet/" class="sidebar-link">工具函数/代码片段</a></li><li><a href="/blog/algorithm/" class="sidebar-link">数据结构/算法</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="常见的浏览器内核"><a href="#常见的浏览器内核" class="header-anchor">#</a> 常见的浏览器内核</h2> <ul><li>Trident 内核：IE, 360，搜狗浏览器 MaxThon、TT、The World,等。[又称 MSHTML]</li> <li>Gecko 内核：火狐，FF，MozillaSuite / SeaMonkey 等</li> <li>Blink内核：Opera7 及以上。[Opera 内核原为：Presto，现为：Blink]</li> <li>Webkit 内核：Safari，Chrome 等。 [ Chrome 的：Blink（WebKit 的分支）]</li></ul> <h2 id="对浏览器内核的理解"><a href="#对浏览器内核的理解" class="header-anchor">#</a> 对浏览器内核的理解</h2> <ul><li>内核主要分成两部分：渲染引擎(layout engineer 或 Rendering Engine) 和 JS 引擎。</li> <li>渲染引擎</li> <li>负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。 浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。 所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</li> <li>JS 引擎</li> <li>解析和执行 javascript 来实现网页的动态效果。</li> <li>最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</li></ul> <h2 id="v8引擎"><a href="#v8引擎" class="header-anchor">#</a> v8引擎</h2> <p>chrome的V8，firefox的SpiderMonkey，Safari的Nitro</p> <p>常用的4个模块:</p> <ul><li>parser: 将JavaScript代码转换为抽象语法树(ast),  js源码 --<code>词法分析--</code> tokens --<code>语法分析 --</code> AST, token过程具体由一个名为scanner的</li> <li>lgnition: lgnition是V8提供的一个解释器, 他的作用是负责将抽象语法树转换为字节码, 同时收集下一个极端(编译)所需要的信息, 这个过程, 我们可以理解为预编译过程.</li> <li>TurboFan: V8引擎的编译器模块, 利用lgnition收集到的信息, 将字节码转换为汇编代码</li> <li>orinoco: 垃圾回收模块, orinoco也是使用标记清除法来进行垃圾回收</li></ul> <h2 id="post和get区别"><a href="#post和get区别" class="header-anchor">#</a> <a href="https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd" target="_blank" rel="noopener noreferrer">post和get区别<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h2> <p><img src="/blog/assets/img/diff.4df059e4.png" alt="post和get区别"></p> <p>状态码<br> <img src="/blog/assets/img/status-code.98629515.png" alt="http状态码"></p> <h2 id="敲入url到渲染完成的整个过程"><a href="#敲入url到渲染完成的整个过程" class="header-anchor">#</a> 敲入URL到渲染完成的整个过程</h2> <ul><li>输入地址</li> <li>浏览器引入了DNS预取技术, 利用现有的DNS机制, 提前解析网页中可能的网络连接,</li> <li>当我们开始输入网址的时候, 浏览器其实已经在智能的匹配可能的url了, 会从历史记录,书签等地方. 找到已经输入的字符串可能对应的url,给出智能提示, 可以补全url地址, 还没有按下enter时, 浏览器已经开始使用DNS预取技术解析域名了.</li> <li>根据DNS查找对应的IP地址
<ul><li>浏览器搜索自己的DNS缓存</li> <li>没有缓存时, 在操作系统的缓存中查找, 这一步会查找本机的hosts, 查找对应的域名映射</li> <li>系统缓存也没有, 就到路由器查找, 一般路由器也会有dns缓存</li> <li>如没有, 操作系统将域名发送至本地域名服务器--递归查询方式, 本地域名服务器查询自己的dns缓存, 查找成功则返回结果, 否则采用迭代查询方式,  本地域名服务器为网络接入服务器商, 比如中国电信, 中国移动</li> <li>本地域名服务器将得到的IP地址返回给操作系统, 同时将IP地址缓存起来</li> <li>操作系统将IP地址返回给浏览器, 同时也将IP地址缓存起来,</li> <li>至此, 浏览器已经得到域名对应的IP地址</li></ul></li> <li>建立TCP连接
<ul><li>TCP是一种面向有连接的传输层协议, 他可以保证两端通信主机之间的通信可达, 他能够处理在传输过程中丢包, 传输顺序乱掉等异常情况, 此外他还能有效利用带宽,缓解网络拥堵.</li> <li>通过三次握手建立tcp连接</li> <li>在tcp连接建立完成之后,就可以发送Http请求了</li> <li>断开连接, 四次挥手.</li></ul></li> <li>服务器收到请求并相应
<ul><li>在接收和解释请求消息后服务器返回一个http响应消息</li> <li>http响应由三个部分组成, 分别是 状态行, 消息报头, 响应正文</li></ul></li> <li>浏览器接收服务器响应结果并处理
<ul><li>解析HTML, 构建DOM树,</li> <li>解析CSS, 生成CSS规则树,</li> <li>合并DOM树和CSS树, 生成render树</li> <li>布局render树, 负责各元素尺寸,位置的计算</li> <li>绘制render树, 绘制页面像素信息</li> <li>浏览器会将各层的信息发送GPU, GPU会将各层合成(composite),显示在屏幕
<ul><li>构造DOM树
<ul><li>在webkit中 HTML解释器将字节流解码成字符流, 然后通过词法分析器解释成词语(token), 之后经过语法分析器构建成节点, 最后这些节点被组建成一颗DOM树</li> <li>浏览器在解析html文件过程中, 会自上而下加载, 并在加载过程中进行解析渲染,在解析过程中, 如果遇到请求外部资源,请求过程是异步的,不影响html文档加载</li> <li>html的解释, 布局, 渲染等工作基本上就是工作在渲染线程上, 因为DOM树只能在渲染线程上创建和访问</li> <li>解析过程中, 浏览器首先会解析HTML文件构建DOM树, 然后解析css文件构建render树, 等到render树构建完成后,浏览器开始布局render树并将其绘制在屏幕上</li></ul></li> <li>解释css
<ul><li>css解释过程是指从css字符串经过css解释器处理后变成渲染引擎内部规则的表示过程</li> <li>生成样式规则后, 会进行样式规则匹配,规则的匹配则是由ElementRuleCollector类来计算并获得, 并从DocumentRuleSets类中获取规则集合, 依次按照ID,class,标签等匹配获得元素的样式.</li> <li>从整个网页的加载和渲染过程来看, Css解释和规则匹配处于DOM树建立之后, RenderObject树建立之前, CSS解释器解释后的结果会保存起来,然后RenderObject树基于该结果来进行规范匹配和布局计算.</li></ul></li> <li>渲染过程遇到js
<ul><li>当文档加载过程遇到js文件, html文档会挂起渲染(加载解析渲染)的线程, 不仅要等待文档中js文件加载完毕, 还要等待解析执行完毕,才可以恢复html文档的渲染线程,因为js有可能会修改dom, 最为经典的document.write</li> <li>DOM树构建完之后, webkit触发DOMContentLoaded事件, 当所有资源被加载完之后, webkit触发onload事件</li> <li>webkit将dom树构建过程中需要执行的js代码交由HTMLScriptRunner类来负责</li> <li>js的执行机制可以看做是一个主线程加上一个任务队列, 同步任务就是放在主线程上执行的任务, 异步任务就是放在任务队列中的任务, 所有同步任务在主线程上执行,形成一个执行栈, 异步任务有了运行结果就会在任务队列中放置一个事件, 脚本运行时先一次运行执行栈, 然后会从任务队列里提取事件,运行任务队列中的任务,不断重复.</li></ul></li> <li>渲染合成render树
<ul><li>Html经过解释后, 生成DOM树, 在DOM树构建完成之后, webkit会为dom树节点构建RenderObject树, 再通过RenderObject树构建出RenderLayer树</li> <li>renderObject树是基于DOM树建立起来的一颗新树, RenderObject树节点和DOM节点不是一一对应关系, 因为有可视节点与不可视节点.</li> <li>renderLayer节点和RenderObject节点不是一一对应关系, 而是一对多的关系</li></ul></li> <li>布局
<ul><li>当webkit创建RenderObject对象之后, 根据框模型来计算他们的位置.大小等信息</li> <li>布局计算是一个递归的过程, 因为一个节点的大小通常需要先计算他的子女节点的位置, 大小等信息,</li></ul></li> <li>绘图
<ul><li>绘图操作就是绘图上下文, 所有绘图的操作都是在该上下文中来进行的</li> <li>绘图上下文分为两种类型,一是2D图形上下文, 二是3D绘图上下文.</li> <li>网页的渲染方式有三种方式, 1. 软件渲染, 2. 硬件加速渲染,3 混合模式</li> <li>绘图操作使用CPU,称为软件渲染, 使用GPU, 称为硬件加速渲染,</li> <li>理想情况下,每个层都有绘制的存储区域, 用来保存绘图结果, 最后需要将这些层的内容合并到同一个图像之中. 称之为合成(Compositing),</li> <li>所以在完成构建DOM树之后, Webkit会调用绘图操作,软件渲染或硬件加速渲染, 将模型绘制出来.呈现在屏幕上.</li></ul></li></ul></li></ul></li></ul> <h2 id="深入理解https"><a href="#深入理解https" class="header-anchor">#</a> 深入理解https</h2> <p>https: 是在http上建立ssl加密层, 并对传输数据进行加密, 是http协议的安全版,</p> <ul><li>作用:
<ul><li>对数据进行加密, 并建立一个信息安全通道, 来保证传输过程中的数据安全</li> <li>对网站服务器进行真实身份认证</li></ul></li> <li>http协议存在的问题
<ul><li>通信使用明文, 内容可能被窃听.</li> <li>无法证明报文的完整性, 所以可能遭篡改</li> <li>不验证通信方的身份, 有可能遭遇伪装</li></ul></li> <li>https优势
<ul><li>数据隐私性: 内容经过对称加密, 每个链接生成一个唯一的加密秘</li> <li>数据完整性: 内容传输经过完整性校</li> <li>身份认证: 第三方无法伪装服务端(客户端)身份</li></ul></li> <li>如何解决上诉问题
<ul><li>https并非是应用层的一种新协议, 只是http通信接口部分用ssl和tls协议代替而已</li> <li>通常http直接和tcp通信, 当使用ssl时, 则演变成先和ssl通信, 在由ssl和tcp通信.</li> <li>https协议的主要功能基本都依赖于TLS/SSL协议, TLS/SSL的功能实现主要依赖于三类基本算法: 散列函数,对称加密和非对称加密, 其利用非堆成加密实现身份认证和秘钥协商, 对称加密算法采用协商的秘钥对数据加密, 基于散列函数验证信息的完整性.</li> <li>加密. 数字签名. 数字证书</li></ul></li></ul> <h2 id="浏览器缓存实现原理"><a href="#浏览器缓存实现原理" class="header-anchor">#</a> 浏览器缓存实现原理</h2> <ul><li>浏览器缓存将文件保存在客户端, 好的缓存策略可以减少对网络带宽的占用, 可以提高访问速度, 提高用户体验, 还可以减轻服务器的负担</li> <li>当一个客户端请求web服务器, 请求的内容可以从以下几个地方获取, 服务器, 浏览器缓存, 或缓存服务器中, 页面文件有三种缓存状态,
<ul><li>最新的. : 选择不缓存页面. 每次请求时都从服务器获取最新的内容</li> <li>未过期的: 在给定的时间内缓存, 如果用户刷新或页面过期则去服务器请求, 否则读取本地的缓存, 这样可以提高浏览器速度</li> <li>过期的, 重新获取</li></ul></li> <li>页面缓存的状态由http header决定. 一个浏览器请求信息, 一个是服务器响应信息, 主要包括:
<ul><li>Pragma: no-cache, Cache-control, expires, Last-Modified, if-modified-since</li> <li>cache-control的主要参数
<ul><li>cache-control: private/public, public响应会被缓存, 并且在多用户间共享, private响应只能够作为私有的缓存, 不能在用户间共享</li> <li>cache-control:no-cache, 不进行缓存,</li> <li>cache-control: max-age=x 缓存时间, 以秒为单位</li> <li>cache-control must-revalidate, 如果页面过期, 则去服务器获取</li></ul></li> <li>expires 显示的设置页面过期时间</li> <li>last-modified: 请求对象最后一次的修改时间, 用来判断缓存是否过期, 通常有文件的时间信息产生</li> <li>if-modified-since: 客户端发送请求附带的信息, 指浏览器缓存请求对象的最后修改日期, 用来和服务器端的last-modified做比较</li></ul></li></ul> <h2 id="http协议头字段"><a href="#http协议头字段" class="header-anchor">#</a> http协议头字段</h2> <ul><li>http协议头字段.
<ul><li>http的头域包括, 通用头, 请求头, 响应头, 实体头</li> <li>每个头域由一个域名, 冒号, 和域值三部分组成</li> <li>域名大小无关, 域值前可以添加任何数量的空格符, 头域可以被扩展为多行, 在每行开始处, 使用至少一个空格或制表符.</li></ul></li></ul> <h2 id="jwt-json-web-token"><a href="#jwt-json-web-token" class="header-anchor">#</a> JWT(JSON Web Token)</h2> <ul><li>跨域认证问题
<ul><li>互联网用户认证流程
<ul><li>用户向服务器发送用户名和密码</li> <li>服务器验证通过后, 在当前对话(session)里面保存相关数据, 比如用户角色, 登录时间等</li> <li>服务器向用户返回一个session_id, 写入用户Cookie</li> <li>用户随后的每一次请求, 都会通过cookie, 将session_id传回服务器</li> <li>服务器收到session_id, 找到前期保存的数据, 由此得知用户的身份</li></ul></li> <li>这种问题的模式的问题在于, 扩展性不好, 如果是服务器集群, 就要求session数据共享</li></ul></li> <li>JWT
<ul><li>原理: 服务器认证后, 生成一个JSON对象,发回给用户, 用户与服务器通信时, 都要发回这个JSON对象, 服务器完全只靠这个对象认定身份, 为了防止用户篡改数据, 服务器在生成这个对象的时候, 会加上签名,</li> <li>数据结构: 他是一个很长的字符串, 中间用点分隔成三个部分.
<ul><li>Header(头部): JSON对象用来描述JWT的元数据, { alg:'HS256', typ:'JWT' } 使用Base64URl算法转成字符串</li> <li>Payload(负载): JSON对象用来存放实际需要传递的数据, JWT规定了7个官方字段, 除了官方字段,还可以定义私有字段, 也要使用Base64URL算法转为字符串
<ul><li>iss (issuer)：签发人</li> <li>exp (expiration time)：过期时间</li> <li>sub (subject)：主题</li> <li>aud (audience)：受众</li> <li>nbf (Not Before)：生效时间</li> <li>iat (Issued At)：签发时间</li> <li>jti (JWT ID)：编号</li></ul></li> <li>Signature(签名): 对前两部分的签名, 防止数据篡改, 首先需要制定一个秘钥, 这个密钥只有服务器才知道, 不能透露给用户, 然后, 使用Header里面指定的签名算法, 算出签名以后, 把Header, payload, Signature三个部分平成一个字符串, 每个部分之间用点分隔</li></ul></li> <li>使用方式.:客户端收到服务器返回的JWT, 可以存储在cookie里面, 也可以存储在localStorage, 此后,客户端每次与服务器通信, 都要带上这个JWT,可以放在Cookie里面自动发送, 但是这样不能跨域, 更好的方法是放在http请求头信息, Authorization字段里面</li> <li>特点:
<ul><li>默认不加密,</li> <li>不仅可以用于认证, 也可以用于交换信息, 有效使用JWT, 可以降低服务器查询数据库的次数</li> <li>JWT最大的缺点是, 由于服务器不保存session状态, 因此无法在使用过程中废止某个token, 或者更改token的权限, 也就是说 一旦JWT签发了在到期之前始终有效,除非服务器部署额外的逻辑,</li> <li>JWT本身包含了认证信息, 一旦泄露, 任何人都可以获得该令牌的所有权限, 为了减少盗用, JWT的有效期应该设置的比较短,</li> <li>为了减少盗用, JWT不应该使用http, 要使用https传输</li></ul></li> <li>优点:
<ul><li>跨语言通用</li> <li>可以存储业务逻辑所必要的飞敏感信息</li> <li>便于传输, 构成简单, 字节占用小,</li> <li>不需要在服务端保存会话, 易于扩展</li></ul></li></ul></li></ul> <h2 id="xss与csp"><a href="#xss与csp" class="header-anchor">#</a> Xss与CSP</h2> <ul><li>内容安全策略   (CSP) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。</li> <li>CSP 被设计成完全向后兼容（除CSP2 在向后兼容有明确提及的不一致;  更多细节查看这里 章节1.1）。不支持CSP的浏览器也能与实现了CSP的服务器正常合作，反之亦然：不支持 CSP 的浏览器只会忽略它，如常运行，默认为网页内容使用标准的同源策略。如果网站不提供 CSP 头部，浏览器也使用标准的同源策略。</li> <li>为使CSP可用, 你需要配置你的网络服务器返回  Content-Security-Policy  HTTP头部 ( 有时你会看到一些关于X-Content-Security-Policy头部的提法, 那是旧版本，你无须再如此指定它)。</li> <li>除此之外,  <code>meta</code>  元素也可以被用来配置该策略</li> <li>CSP 的主要目标是减少和报告 XSS 攻击 ，XSS 攻击利用了浏览器对于从服务器所获取的内容的信任。恶意脚本在受害者的浏览器中得以运行，因为浏览器信任其内容来源，即使有的时候这些脚本并非来自于它本该来的地方。</li> <li>CSP通过指定有效域——即浏览器认可的可执行脚本的有效来源——使服务器管理者有能力减少或消除XSS攻击所依赖的载体。一个CSP兼容的浏览器将会仅执行从白名单域获取到的脚本文件，忽略所有的其他脚本 (包括内联脚本和HTML的事件处理属性)。</li> <li>作为一种终极防护形式，始终不允许执行脚本的站点可以选择全面禁止脚本执行。</li> <li>除限制可以加载内容的域，服务器还可指明哪种协议允许使用；比如 (从理想化的安全角度来说)，服务器可指定所有内容必须通过HTTPS加载。一个完整的数据安全传输策略不仅强制使用HTTPS进行数据传输，也为所有的cookie标记安全标识 cookies with the secure flag，并且提供自动的重定向使得HTTP页面导向HTTPS版本。网站也可以使用  Strict-Transport-Security  HTTP头部确保连接它的浏览器只使用加密通道。</li> <li>配置内容安全策略涉及到添加 Content-Security-Policy  HTTP头部到一个页面，并配置相应的值，以控制用户代理（浏览器等）可以为该页面获取哪些资源。比如一个可以上传文件和显示图片页面，应该允许图片来自任何地方，但限制表单的action属性只可以赋值为指定的端点。一个经过恰当设计的内容安全策略应该可以有效的保护页面免受跨站脚本攻击。</li> <li>一个策略由一系列策略指令所组成，每个策略指令都描述了一个针对某个特定类型资源以及生效范围的策略。你的策略应当包含一个default-src策略指令，在其他资源类型没有符合自己的策略时应用该策略(有关完整列表查看default-src )。一个策略可以包含 default-src  或者 script-src 指令来防止内联脚本运行, 并杜绝eval()的使用。 一个策略也可包含一个 default-src 或  style-src 指令去限制来自一个 <code>style</code> 元素或者style属性的內联样式。</li></ul> <h2 id="http字段"><a href="#http字段" class="header-anchor">#</a> http字段</h2> <ul><li>通用首部字段（General Header Fields） 请求和响应报文两方都会使用的首部字段。
<ul><li>cache-control 控制缓存</li> <li>connection 连接管理, 逐条首部</li> <li>upgrade 升级为其他协议</li> <li>via 代理服务器的相关信息</li> <li>wraning 错误和警告通知</li> <li>transfor-encoding 报文主题的传输编码格式</li> <li>trailer 报文末端的首部一览</li> <li>pragma 报文指令</li> <li>date 创建报文的日期</li></ul></li> <li>请求首部字段（Reauest Header Fields）客户端向服务器发送请求的报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关的优先等级信息。
<ul><li>Accept  客户端或代理能够处理的媒体类型</li> <li>Accept-encoding 优先可处理的编码格式</li> <li>accept-language 优先可处理的自然语言</li> <li>accept-charset 优先可以处理的字符集</li> <li>if-match 比较实体标记(ETage)</li> <li>if-none-match 比较实体标记与if-match相反</li> <li>if-modified-since 比较资源更新时间</li> <li>if-unmodified-since 比较资源更新时间, 与if-modified-since</li> <li>if-rnages 资源未更新时发送实体byte的范围请求</li> <li>range 实体的字节范围请求</li> <li>authorization web的认证信息</li> <li>proxy-authorization 代理服务器要求web认证信息</li> <li>host 请求资源所在服务器</li> <li>from 用户的邮箱地址</li> <li>user-agent 客户端程序信息</li> <li>max-forwrads 最大的逐跳次数</li> <li>TE 传输编码的优先级</li> <li>referer 请求原始方的url</li> <li>expect 期待服务器的特定行为</li></ul></li> <li>响应首部字段（Response Header Fields）从服务器向客户端响应时使用的字段，补充响应的附加内容，也会要求客户端附加额外信息
<ul><li>accept-ranges 能接受的字节范围</li> <li>age 推算资源创建经过时间</li> <li>location 令客户端重定向的URL</li> <li>vary 代理服务器的缓存信息</li> <li>etag 能够表示资源唯一资源的字符串</li> <li>www-authenticate 服务器要求客户端的验证信息</li> <li>proxy-authenticate 代理服务器要求客户端的验证信息</li> <li>server 服务器的信息</li> <li>retry-after 和状态码503 一起使用的首部字段, 表示下次请求服务器的时间</li></ul></li> <li>实体首部字段（Entiy Header Fields） 针对请求报文和响应报文的实体部分使用首部。补充了资源内容更新时间等实体有关的信息。
<ul><li>allow 资源可支持http请求的方法</li> <li>content-language 实体的资源语言</li> <li>content-encoding 实体的编码格式</li> <li>content-length 实体的大小</li> <li>content-type 实体媒体类型</li> <li>content-MD5 实体报文的摘要</li> <li>content-location代替资源的uri</li> <li>content-rnages 实体主题的位置返回</li> <li>last-modified 资源最后的修改资源</li> <li>expires 实体主题的过期资源</li></ul></li></ul> <h2 id="跨域解决方案"><a href="#跨域解决方案" class="header-anchor">#</a> 跨域解决方案</h2> <ul><li>JSONP:  利用 <code>script</code> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。 缺点:仅支持get方法具有局限性,不安全可能会遭受XSS攻击。</li> <li>CORS: 需要浏览器和后端同事支持,服务端设置Access-ConTrol-Allow-origin就可以开启CORS,
<ul><li>简单请求:
<ul><li>get, head, post</li> <li>content-type: text/plain. multipart/form-data</li> <li>application/x-www-form-urlencoded</li></ul></li> <li>复杂请求: 在正式通讯前,增加一次http查询请求, option方法. 通过该请求来知道服务端是否允许跨域</li></ul></li> <li>postMessage: postMessage是HTML5 XMLHttpRequset Level 2中的api, 且是为数不多可以跨域操作的window属性之一,
<ul><li>window.postMessage(message, targetOrigin, [transfer])
<ul><li>message: 将要发送到其他 window的数据。</li> <li>targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串&quot;*&quot;（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。</li> <li>transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li></ul></li></ul></li> <li>websocket: HTML5的一个持久化的协议, 它实现了浏览器与服务器的全双工通信.同时也是跨域的一种解决方案.
<ul><li>websocket在建立连接时需要借助http协议, 连接建立好了之后client与server之间的双向通信就与http无关了</li></ul></li> <li>node中间件代理
<ul><li>实现原理: 同源策略是浏览器需要遵循的标准, 而如果是服务器向服务器请求就不需要遵循同源策略</li> <li>接受客户端请求,</li> <li>将请求转发给服务器</li> <li>拿到服务器响应数据</li> <li>将响应转发给客户端</li></ul></li> <li>nginx反向代理</li> <li>window.name + iframe</li> <li>location.hash + iframe</li> <li>document.domain + iframe</li></ul> <h2 id="tcp三次握手-四次挥手"><a href="#tcp三次握手-四次挥手" class="header-anchor">#</a> TCP三次握手, 四次挥手</h2> <ul><li>三次握手
<ul><li>客户端发送一个SYN段, 并指明客户端的序列号, ISN(c)</li> <li>服务端发送自己的SYN段作为应答, 同样指明自己的ISN(s), 为了确认客户端的SYN, 将ISN(c) + 1作为ACK数值, 这样每发送一个SYN. 序列号就会加1, 如果丢失,则会重传</li> <li>为了确认服务器端的SYN, 客户端将ISN(s)+1作为返回的ACK数值</li></ul></li> <li>四次挥手
<ul><li>客户端发送一个FIN段, 并包含一个希望接受者看到的自己当前的序列号, 同时还包含一个ACK表示确认对方最近一次发过来的数据</li> <li>服务端将K值加1作为ACK序号值, 表明收到了上一个包,这时上层的应用程序会被告知另一端发起了关闭操作, 通常这将引起应用程序发起自己的关闭操作,</li> <li>服务端发起自己的FIN段, ACK = K+1, Seq= L</li> <li>客户端确认 ACK=L+1</li></ul></li></ul> <h2 id="移动端点击事件"><a href="#移动端点击事件" class="header-anchor">#</a> 移动端点击事件</h2> <ul><li>移动端有touchstart. touchmove, touchend, tap</li> <li>pc端有 mousedown, mousemove, mouseup, click</li> <li>zepto.js  tap事件解决了一个300ms延迟问题，却带来了一个新的重大bug，点击穿透。</li> <li>fastclick.js则是在想办法让click事件的延迟消除</li></ul> <h2 id="事件委托-事件代理"><a href="#事件委托-事件代理" class="header-anchor">#</a> 事件委托(事件代理):</h2> <ul><li>把一个元素响应事件的函数委托到另一个元素, 一般来讲,会把一组元素的事件委托到父层,或者更DOM中事件委托的实现是利用事件冒泡的机制,</li></ul> <h2 id="webrtc-实时通讯技术"><a href="#webrtc-实时通讯技术" class="header-anchor">#</a> WebRTC: 实时通讯技术.</h2></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/docker/" class="prev">
        Docker
      </a></span> <span class="next"><a href="/blog/snippet/">
        工具函数/代码片段
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.00e18691.js" defer></script><script src="/blog/assets/js/2.db07618b.js" defer></script><script src="/blog/assets/js/5.b7c661e0.js" defer></script>
  </body>
</html>
